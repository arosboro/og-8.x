<?php

/**
 * @file
 * Enable users to create and manage groups with roles and permissions.
 */

// Add field widget related code.
require DRUPAL_ROOT . '/' . drupal_get_path('module', 'og') . '/includes/og.field.inc';

/**
 * Define active group content states.
 *
 * When a user has this membership state they are considered to be of
 * "member" role.
 */
define('OG_STATE_ACTIVE', 1);

/**
 * Define pending group content states. The user is subscribed to the group
 * but isn't an active member yet.
 *
 * When a user has this membership state they are considered to be of
 * "non-member" role.
 */
define('OG_STATE_PENDING', 2);

/**
 * Define blocked group content states. The user is rejected from the group.
 *
 * When a user has this membership state they are denied access to any
 * group related action. This state, however, does not prevent user to
 * access a group or group content node.
 */
define('OG_STATE_BLOCKED', 3);

/**
 * Group audience field.
 */
define('OG_AUDIENCE_FIELD', 'og_group_ref');

/**
 * Group field.
 */
define('OG_GROUP_FIELD', 'group_group');

/**
 * Group default roles and permissions field.
 */
define('OG_DEFAULT_ACCESS_FIELD', 'og_roles_permissions');

/**
 * The role name of group non-members.
 */
define('OG_ANONYMOUS_ROLE', 'non-member');

/**
 * The role name of group member.
 */
define('OG_AUTHENTICATED_ROLE', 'member');

/**
 * The role name of group administrator.
 */
define('OG_ADMINISTRATOR_ROLE', 'administrator member');

/**
 * The default group membership type that is the bundle of group membership.
 */
define('OG_MEMBERSHIP_TYPE_DEFAULT', 'og_membership_type_default');

/**
 * The name of the user's request field in the default group membership type.
 */
define('OG_MEMBERSHIP_REQUEST_FIELD', 'og_membership_request');

/**
 * Implements hook_permission().
 */
function og_permission() {
  return array(
    'administer group' =>  array(
      'title' => t('Administer Organic groups permissions'),
      'description' => t('Administer all groups and permissions.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function og_menu() {
  $items = array();

  // Add our own autocomplete callback to pass also the group and
  // vocabulary info.
  $items['og/autocomplete/single/%/%/%/%'] = array(
    'title' => 'Entity Reference Autocomplete',
    'page callback' => 'og_entityreference_autocomplete_callback',
    'page arguments' => array(2, 3, 4, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['og/autocomplete/tags/%/%/%/%'] = array(
    'title' => 'Entity Reference Autocomplete',
    'page callback' => 'og_entityreference_autocomplete_callback',
    'page arguments' => array(2, 3, 4, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function og_entity_info() {
  $items['og_membership_type'] = array(
    'label' => t('OG membership type'),
    'controller class' => 'EntityAPIControllerExportable',
    'entity class' => 'OgMembershipType',
    'base table' => 'og_membership_type',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'description',
      'name' => 'name',
    ),
    'exportable' => TRUE,
    'export' => array(
      'default hook' => 'default_og_membership_type',
    ),
    'bundle of' => 'og_membership',
    'module' => 'og',
    'metadata controller class' => 'EntityDefaultMetadataController',
    'views controller class' => 'EntityDefaultViewsController',
    'access callback' => 'og_membership_type_access',
    'entity cache' => module_exists('entitycache'),
  );

  if (class_exists('OgMembershipTypeUIController')) {
    $items['og_membership_type'] += array(
      // Enable the entity API's admin UI.
      'admin ui' => array(
        // TODO: This path doesn't exist before OG-ui.
        'path' => 'admin/config/group/group-membership',
        'file' => 'includes/og.admin.inc',
        'controller class' => 'OgMembershipTypeUIController',
      ),
    );
  }

  $items['og_membership'] = array(
    'label' => t('OG membership'),
    'entity class' => 'OgMembership',
    'controller class' => 'EntityAPIController',
    'base table' => 'og_membership',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      // The message has no label.
      'label' => FALSE,
      'bundle' => 'type',
    ),
    'label callback' => 'og_membership_label',
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'name',
    ),
    'module' => 'og',
    'metadata controller class' => 'OgMembershipMetadataController',
    'views controller class' => 'OgMembershipViewsController',
    'access callback' => 'og_membership_access',
//    'entity cache' => \Drupal::moduleHandler()->moduleExists(entitycache),
  );

  // Add bundle info but bypass entity_load() as we cannot use it here.
  if (db_table_exists('og_membership_type')) {
    $memberships = db_select('og_membership_type', 'g')
        ->fields('g')
        ->execute()
        ->fetchAllAssoc('name');

    foreach ($memberships as $type_name => $type) {
      $items['og_membership']['bundles'][$type_name] = array(
        'label' => $type->name,
        'admin' => array(
          'path' => 'admin/config/group/group-membership/manage/%og_membership_type',
          'real path' => 'admin/config/group/group-membership/manage/' . $type->name,
          'bundle argument' => 5,
          'access arguments' => array('administer group'),
        ),
      );
    }
  }

  return $items;
}

/**
 * Implements hook_entity_field_info().
 */
function og_entity_field_info($entity_type) {
  $info = array();
  return;

  // Add OG membership metadata for every bundle that is a group content.
  foreach (og_get_all_group_content_bundle() as $entity_type => $bundles) {
    foreach ($bundles as $bundle => $bundle_value) {
      $info['optional']['og_membership'] = array(
        'label' => t("OG memberships"),
        'type' => 'og_membership',
        'list' => TRUE,
        'description' => t("A list of all OG memberships of the @name entity.", array('@name' => $entity_type)),
        'getter callback' => 'og_get_og_membership_properties',
        'class' => '\Drupal\og\Entity\OgMembership',
      );
      $info['bundle map'][$bundle][] = 'og_membership';

      // Add per-state properties.
      $general = $info['optional']['og_membership'];
      foreach (og_group_content_states() as $state => $state_label) {
        $params = array('@state' => $state_label, '@name' => $entity_type);
        $info['optional']['og_membership__' . $state] = $general;
        $info['optional']['og_membership__' . $state]['label'] = t('@state OG membership', $params);
        $info['optional']['og_membership__' . $state]['description'] = t("A list of all OG memberships of the @name entity with @state state.", $params);
        $info['bundle map'][$bundle][] = 'og_membership__' . $state;
      }

      // Add OG membership per field in a bundle.
      foreach (og_get_group_audience_fields($entity_type, $bundle) as $field_name => $label) {
        $params = array('@label' => $label);
        $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
        $field_settings = $field->getFieldSettings();
        $group_type = $field_settings['target_type'];
        $info['optional'][$field_name . '__og_membership'] = array(
          'label' => t('OG membership from field @label', $params),
          'type' => 'og_membership',
          'list' => TRUE,
          // The bundle in this context means the OG membership type.
          'bundle' => $field_settings['handler_settings']['membership_type'],
          'description' => t('A list of all OG memberships registered in field @label.', $params),
          'getter callback' => 'og_get_field_og_membership_properties',
          'class' => '\Drupal\og\Entity\OgMembership',
        );
        $info['bundle map'][$bundle][] = $field_name . '__og_membership';

        // Add per-state properties.
        $general = $info['optional'][$field_name . '__og_membership'];
        foreach (og_group_content_states() as $state => $state_label) {
          $params = array(
            '@label' => $label,
            '@label' => $label,
            '@state' => $state_label,
          );
          $info['optional'][$field_name . '__og_membership__' . $state] = $general;
          $info['optional'][$field_name . '__og_membership__' . $state]['label'] = t('@state OG memberships from field @label', $params);
          $info['optional'][$field_name . '__og_membership__' . $state]['description'] = t('A list of all OG memberships with @state registered in field @label.', $params);
          $info['bundle map'][$bundle][] = $field_name . '__og_membership';
        }
      }
    }
  }

  foreach (og_get_all_group_bundle() as $entity_type => $bundles) {
    foreach ($bundles as $bundle => $bundle_value) {
      $info['optional']['members'] = array(
        'label' => t("Group members"),
        'type' => 'user',
        'list' => TRUE,
        'description' => t("A list group members of the @name entity.", array('@name' => $entity_type)),
        'getter callback' => 'og_get_group_members_properties',
        'class' => '\Drupal\user\Entity\User',
      );
      $info['bundle map'][$bundle][] = 'members';

      // Add per-state properties.
      $general = $info['optional']['members'];
      foreach (og_group_content_states() as $state => $state_label) {
        $params = array('@state' => $state_label, '@name' => $entity_type);
        $info['optional']['members__' . $state] = $general;
        $info['optional']['members__' . $state]['label'] = t('@state group members', $params);
        $info['optional']['members__' . $state]['description'] = t("A list of all users of the @name entity with @state state.", $params);
        $info['bundle map'][$bundle][] = 'members__' . $state;
      }
    }
  }

  return $info;
}

/**
 * Property getter callback for group members.
 *
 * @see og_entity_property_info()
 */
function og_get_group_members_properties($entity, array $options, $name, $type) {
  $args = explode('__', $name);
  $state = !empty($args[1]) ? $args[1] : FALSE;
  $id = $entity->id();

  $cache = &drupal_static(__FUNCTION__, array());
  if (isset($cache[$type][$id][$state])) {
    // Return the cached result.
    return $cache[$type][$id][$state];
  }
  $cache[$type][$id][$state] = array();

  $query = \Drupal::entityQuery('og_membership');
  $query
      ->condition('group_type', $type, '=')
      ->condition('gid', $id, '=')
      ->condition('entity_type', 'user', '=');

  if ($state) {
    $query->condition('state', $state, '=');
  }

  $result = $query->execute();
  if (!empty($result['og_membership'])) {
    $og_memberships = og_membership_load_multiple(array_keys($result['og_membership']));
    foreach ($og_memberships as $og_membership) {
      $cache[$type][$id][$state][] = $og_membership->etid;

    }
  }
  return $cache[$type][$id][$state];
}

/**
 * Property getter callback for OG membership.
 *
 * @see og_entity_property_info()
 */
function og_get_og_membership_properties($entity, array $options, $name, $type) {
  // Get the state from name, if exists.
  if ($name == 'og_membership') {
    $state = array();
  }
  else {
    $args = explode('__', $name);
    $state = array($args[1]);
  }

  $ids = array();

  if ($gids = og_get_entity_groups($type, $entity, $state)) {
    $ids = array();
    foreach ($gids as $group_type => $values) {
      $ids = array_merge($ids, array_keys($values));
    }
  }

  return $ids;
}

/**
 * Property getter callback for OG membership per field.
 *
 * @see og_entity_property_info()
 */
function og_get_field_og_membership_properties($entity, array $options, $name, $type) {
  $args = explode('__', $name);
  // Field name might have double underscore as-well, so we need to make
  // sure we get it right.
  $last_char = substr($name, -1);
  $state = is_numeric($last_char) ? $last_char : FALSE;

  // The number of characters to ignore in the name (i.e. remove the
  // "__og_membership" or "__og_membership__0").
  $remove_char = $state ? -18 : -15;
  $field_name = substr($name, 0, $remove_char);

  $field_name = $args[0];
  $state = count($args) == 2 ? FALSE : $args[2];
  $id = $entity->id();

  $identifier = $type . ':' . $id . ':' . $field_name . ':' . $state;
  $cache = &drupal_static(__FUNCTION__, array());
  if (isset($cache[$identifier])) {
    // Return the cached result.
    return $cache[$identifier];
  }

  $query = \Drupal::entityQuery('og_membership');
  $query
      ->condition('entity_type', $type, '=')
      ->condition('etid', $id, '=')
      ->condition('field_name', $field_name, '=');

  if ($state) {
    $query->condition('state', $state, '=');
  }

  $result = $query->execute();
  $cache[$identifier] = !empty($result['og_membership']) ? array_keys($result['og_membership']) : array();
  return $cache[$identifier];
}

/**
 * Implements hook_field_create_instance().
 *
 * - Create default OG roles per entity-type and bundle.
 * - Create a group audience field on the user's entity, referencing the first
 *   group defined.
 */
function og_field_create_instance($entity) {
  if ($entity->getFieldName() != OG_GROUP_FIELD) {
    return;
  }

//   TODO og_roles_override
  // Create default roles per entity-type per bundle.
//  og_roles_override($entity->entityType(), $entity->bundle(), 0);

  // Check if we need to add a group audience on the user's entity.
  // We add a different field, so each field can be set differently.
  $entity_type = $entity->entity_type;
  $bundle = $entity->bundle;

  foreach (array_keys(og_get_group_audience_fields()) as $field_name) {
    $field = \Drupal\field\Field::fieldInfo()->getField('user', $field_name);

    $settings = $field->getFieldSettings();
    if ($settings['target_type'] == $entity_type  && empty($settings['handler_settings']['target_bundles'])) {
      return;
    }

    if ($settings['target_type'] == $entity_type && in_array($bundle, $settings['handler_settings']['target_bundles'])) {
      return;
    }
  }

  // If we reached here, it means we need to create a field.
  // Pick an unused name.
  $field_name = substr("og_user_$entity_type", 0, 32);
  $i = 1;
  while (\Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name)) {
    $field_name = substr("og_user_$entity_type", 0, 32 - strlen($i)) . $i;
    ++$i;
  }

  $og_field = og_fields_info(OG_AUDIENCE_FIELD);
  $og_field['field']['settings']['target_type'] = $entity_type;
  $og_field['instance']['label'] = t('Group membership');

  // If the user entity type has multiple bundles, make sure to attach a field
  // entity to all of them.
  $entity_bundles = entity_get_bundles('user');
  foreach ($entity_bundles as $user_bundle => $bundle_info) {
    og_create_field($field_name, 'user', $user_bundle, $og_field);
  }
}

/**
 * Implements field_delete_instance().
 *
 * - Invalidate OG's static cache if a group-audience field is deleted.
 * - Delete the default OG roles per entity-type and bundle.
 */
function og_field_delete_instance($entity) {
  if (og_is_group_audience_field($entity->entity_type, $entity->getFieldName())) {
    og_invalidate_cache();
  }

  if ($entity->getFieldName() != OG_GROUP_FIELD) {
    return;
  }

  // Get the per-bundle roles.
  // TODO og_roles
  /*roles = og_roles($entity->entityType(), $entity->bundle());
  foreach ($roles as $rid => $name) {
    og_role_delete($rid);
  }*/
}

/**
 * Implements hook_entity_insert().
 */
function og_entity_insert(\Drupal\Core\Entity\EntityInterface $entity) {
  // React when different types of entities are created.
  switch ($entity->entityType()) {
    case 'field_instance':
      og_field_create_instance($entity);
      break;

    default:
      break;
  }

  if (!og_is_group($entity)) {
    return;
  }
  $id = $entity->id();
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();

  if ($entity_type == 'node' && $uid = $entity->getAuthorId() && !empty($uid) || $entity_type == 'user' && $uid = $entity->id()) {
    // Subscribe the group manager.
    og_group($entity_type, $id, array('entity' => $uid));
    // Assign roles to group manager.
    // TODO assign roles
    /*
    $name = 'og_group_manager_default_rids_' . $entity_type . '_' . $bundle;
    if ($rids = variable_get($name)) {
      foreach ($rids as $rid) {
        og_role_grant($entity_type, $id, $entity->uid, $rid);
      }
    }
    */
  }
  // TODO roles
  /*
  if (!og_is_group_default_access($entity_type, $entity)) {
    // Override default roles.
    og_roles_override($entity_type, $bundle, $id);
  }
  */
}

/**
 * Implements hook_entity_update().
 */
function og_entity_update(\Drupal\Core\Entity\EntityInterface $entity) {
  if (!og_is_group($entity)) {
    return;
  }

  $id = $entity->id();
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();
  $uid = ($entity_type == 'node') ? $entity->getAuthorId() : (($entity_type == 'user') ? $entity->id() : 0);
  if (!empty($uid) && !og_is_member($entity_type, $id, 'user', $uid)) {
    // Subscribe the group manager, in case the owner changed.
    og_group($entity_type, $id, array('entity' => $uid));
    // Assign roles to group manager.
    // TODO roles
    /*$name = 'og_group_manager_default_rids_' . $entity_type . '_' . $bundle;
    if ($rids = variable_get($name)) {
      foreach ($rids as $rid) {
        og_role_grant($entity_type, $id, $entity->uid, $rid);
      }
    }*/
  }
  $original_entity = $entity->original;
  // TODO OG_DEFAULT_ACCESS_FIELD
  /*$property = OG_DEFAULT_ACCESS_FIELD;

  if (!empty($entity->{$property}) && $entity->{$property} != $original_entity->{$property}) {
    if (!og_is_group_default_access($entity_type, $entity)) {
      // Override default roles.
      og_roles_override($entity_type, $bundle, $id);
    }
    else {
      // Delete overridden roles.
      og_delete_user_roles_by_group($entity_type, $entity);
    }
  }*/
}

/**
 * Implements hook_entity_delete().
 */
function og_entity_delete(\Drupal\Core\Entity\EntityInterface $entity) {
  // React when different types of entities are created.
  switch ($entity->entityType()) {
    case 'field_instance':
      og_field_delete_instance($entity);
      break;

    default:
      break;
  }
}

/**
 * Implements hook_field_storage_pre_insert().
 */
function og_field_storage_pre_insert(\Drupal\Core\Entity\EntityInterface $entity, $skip_fields) {
  _og_update_entity_fields($entity, $skip_fields);
}

/**
 * Implements hook_field_storage_pre_update().
 */
function og_field_storage_pre_update(\Drupal\Core\Entity\EntityInterface$entity, $skip_fields) {
  _og_update_entity_fields($entity, $skip_fields);
}

/**
 * Update the field values in the entity, to reflect the membership.
 *
 * This is used to allow other modules that save a new/ existing entity
 * to act on the field values, even before hook_field_load() is called.
 */
function _og_update_entity_fields(\Drupal\Core\Entity\EntityInterface $entity, $skip_fields) {
  $id = $entity->id();
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();
  if (!og_is_group_content_type($entity_type, $bundle)) {
    return;
  }

  foreach (og_get_group_audience_fields($entity_type, $bundle) as $field_name => $label) {
    $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);;
    $gids = array();
    if ($field['cardinality'] == 1) {
      if ($og_membership = $field->getValue($field_name . '__og_membership')) {
        // Wrapper return an array.
        $gids = $og_membership[0]->gid;
      }
    }
    else {
      foreach ($field->getValue($field_name . '__og_membership') as $og_membership) {
        $gids[] = $og_membership->gid;
      }
    }
    if ($gids) {
      $field->setValue($gids);
    }
  }
}

/**
 * OG membership type loader.
 *
 * @param $name
 *   (optional) The name for this membership type. If no type is given all existing
 *   types are returned.
 *
 * @return OgMembershipType
 *   Returns a fully-loaded membership type definition if a type name is passed.
 *   Else an array containing all types is returned.
 */
function og_membership_type_load($name = NULL) {
  // Replace dashes with underscores so this can be used as menu argument
  // loader too.
  $types = entity_load_multiple('og_membership_type', isset($name) ? array(strtr($name, array('-' => '_'))) : NULL);
  if (isset($name)) {
    return isset($types[$name]) ? $types[$name] : FALSE;
  }
  return $types;
}

/**
 * Reset static cache related to group membership.
 */
function og_membership_invalidate_cache() {
  $caches = array(
    'og_get_entity_groups',
    'og_get_membership',
    'og_get_field_og_membership_properties',
  );

  foreach ($caches as $cache) {
    drupal_static_reset($cache);
  }
}

/**
 * Return TRUE if the entity is acting as a group.
 *
 * @param $entity
 *   The entity object, or the entity ID.
 *
 * @return boolean
 */
function og_is_group(\Drupal\Core\Entity\EntityInterface $entity) {
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();

  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, OG_GROUP_FIELD);
  if (!$field) {
// TODO make config entity
    return;
//    return variable_get("og_is_group__{$entity_type}__{$bundle}", FALSE);
  }

  $value = $entity->{OG_GROUP_FIELD}->value;
  return !empty($value);
}

/**
 * Get the first best matching group-audience field.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object.
 * @param $group_type
 *   The group type.
 * @param $group_bundle
 *   The group bundle.
 * @param $skip_access
 *   TRUE, if current user access to the field, should be skipped.
 *   Defaults to FALSE.
 *
 * @return string
 *   Field name of the group audience field.
 */
function og_get_best_group_audience_field($entity_type, $entity, $group_type, $group_bundle, $skip_access = FALSE) {
  $bundle = $entity->bundle();

  $field_names = og_get_group_audience_fields($entity_type, $bundle);
  if (!$field_names) {
    return;
  }
  foreach ($field_names as $field_name => $label) {
    $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
    $settings = $field->getFieldSettings();
    if ($settings['target_type'] != $group_type) {
      // Group type doesn't match.
      continue;
    }
    if (!empty($settings['handler_settings']['target_bundles']) && !in_array($group_bundle, $settings['handler_settings']['target_bundles'])) {
      // Bundles don't match.
      continue;
    }


    if (!og_check_field_cardinality($entity_type, $entity, $field_name)) {
      // Field reached maximum.
      continue;
    }

    if (!$skip_access && !field_access('view', $field, $entity_type, $entity)) {
      // User can't access field.
      continue;
    }

    return $field_name;
  }
}


/**
 * Determine if a field can be used and has not reached maximum values.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object or entity ID.
 * @param $field_name
 *   The group audience field name.
 * @return boolean
 *   TRUE|FALSE
 */
function og_check_field_cardinality($entity_type, $entity, $field_name) {
  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  if ($field->getFieldCardinality() == \Drupal\Core\Field\FieldDefinitionInterface::CARDINALITY_UNLIMITED) {
    return TRUE;
  }

  if (is_numeric($entity)) {
    $entity = entity_load($entity_type, $entity);
  }

  return count($entity->getValue($field_name . '__og_membership')) < $field->getFieldCardinality();
}

/**
 * Set an association (e.g. subscribe) an entity to a group.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group entity or ID.
 * @param $values
 *   Array with the information to pass along, until it is processed in the
 *   field handlers.
 *   - "entity_type": (optional) The entity type (e.g. "node" or "user").
 *     Defaults to 'user'
 *   - "entity": (optional) The entity object or entity Id to set the
 *     association. Defaults to the current user if the $entity_type property is
 *     set to 'user'.
 *   - "field_name": The name of the field, the membership should be registered
 *     in. If no value given, a first field with the correct membership type
 *     will be used. If no field found, an execpetion will be thrown.
 * @param $save_created
 *    (optional) If the OG membership is new, it determines whether the
 *    membership will be saved. Defaults to TRUE.
 *
 * @throws \Drupal\og\OgException
 *   When a group audience field cannot be found.
 *
 * @return \Drupal\og\Entity\OgMembership
 *   The OG membership entity.
 */
function og_group($group_type, $gid, $values = array(), $save_created = TRUE) {
  global $user;
  // Set default values.
  $values += array(
    'entity_type' => 'user',
    'entity' => FALSE,
    'field_name' => FALSE,
    'state' => OG_STATE_ACTIVE,
  );

  $entity_type = $values['entity_type'];
  $entity = $values['entity'];
  $field_name = $values['field_name'];
  $state = $values['state'];

  if ($entity_type == 'user' && empty($entity)) {
    $entity = $user->id();
  }

  // If entity was an ID, get the object.
  $entity = entity_load($entity_type, $entity);
  $bundle = $entity->bundle();
  $id = $entity->id();

  if (is_object($gid)) {
    $group = $gid;

  }
  else {
    $group = entity_load($group_type, $gid);
  }

  // the group ID might be the entity, so re-populate it.
  $gid = $group->id();
  $group_bundle = $group->bundle();

  // Get membership if exists.
  $og_membership = og_get_membership($group_type, $gid, $entity_type, $id);

  if (!$og_membership && empty($field_name)) {
    $params = array(
      '%entity-type' => $entity_type,
      '%bundle' => $bundle,
      '%group-type' => $group_type,
      '%group-bundle' => $group_bundle,
    );

    // Allow getting fields not accessible by the user.
    $field_name = og_get_best_group_audience_field($entity_type, $entity, $group_type, $group_bundle, TRUE);
    if (!$field_name) {
      throw new \Drupal\og\OgException(format_string('There are no OG fields in entity %entity-type and bundle %bundle referencing %group-type - %group-bundle.', $params));
    }
  }

  if ($og_membership) {
    if (empty($og_membership->is_new) && $og_membership->field_name == $field_name && $og_membership->state == $state) {
      // Entity is already associated with group.
      return $og_membership;
    }
    elseif (!empty($field_name) && $og_membership->field_name != $field_name) {
      // Ungroup the current association, as it needs to change field.
      og_ungroup($group_type, $gid, $entity_type, $id);
      $og_membership = FALSE;
    }
    elseif ($og_membership->state != $state){
      // Change the state.
      $og_membership->state = $state;
    }
    else {
      // Nothing changed.
      return $og_membership;
    }
  }

  if (!$og_membership) {
    // Unset the values, so we don't try to process them.
    unset($values['entity_type'], $values['entity'], $values['field_name']);
    // Create a new OG membership.
    $og_membership = og_membership_create($group_type, $gid, $entity_type, $id, $field_name, $values);
  }

  if (empty($og_membership->is_new) || $save_created) {
    // Save the membership for update, or if the OG membership is new when
    // "save-created" is TRUE.
    $og_membership->save();
  }

  return $og_membership;
}

/**
 * Creates a new OG membership.
 *
 * If a group membership already exists, an exception will be thrown.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $entity_type
 *   The entity type of the group content.
 * @param $etid
 *   The entity ID of the group content.
 * @param $field_name
 *   The group audience field name.
 * @param $values
 *   (optional) Array of fields values to be attached to the OG membership, that
 *   will be processed using entity-metadata wrapper.
 *
 * @throws \Drupal\og\OgException
 *   When the field_name passed is not a group audience field.
 *
 * @return \Drupal\og\Entity\OgMembership
 *   Returns a new OG membership object.
 *
 * @see entity_property_values_create_entity()
 */
function og_membership_create($group_type, $gid, $entity_type, $etid, $field_name, $values = array()) {
  $language = Drupal::languageManager()->getLanguage();

  $values += array(
    'group_type' => $group_type,
    'gid' => $gid,
    'entity_type' => $entity_type,
    'etid' => $etid,
    'state' => OG_STATE_ACTIVE,
    'created' => time(),
    'field_name' => $field_name,
    'language' => $language->id,
  );

  if (!og_is_group_audience_field($entity_type, $field_name)) {
    throw new \Drupal\og\OgException(format_string('%field-name is not a valid group-audience field.', array('%field-name' => $field_name)));
  }

  $entity = entity_load($entity_type, $etid);
  $bundle = $entity->bundle();

  // Get the type from the field.
  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  $handler_settings = $field->getFieldSetting('handler_settings');
  $values['type'] = $handler_settings['membership_type'];

  return entity_create('og_membership', $values);;
}

/**
 * OG membership loader.
 *
 * @param $name
 *   (optional) The name for this group membership. If no type is given all existing
 *   types are returned.
 *
 * @return OgMembership
 *   Returns a fully-loaded group membership definition if a type name is passed.
 *   Else an array containing all types is returned.
 */
function og_membership_load($name = NULL) {
  return entity_load('og_membership', $name);
}

/**
 * Load multiple OG membership entities based on certain conditions.
 *
 * @param $ids
 *   An array of group membership IDs.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return array
 *   An array of group entities, indexed by group ID.
 */
function og_membership_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load_multiple('og_membership', $ids, $conditions, $reset);
}

/**
 * Get the group membership entity by user and group.
 *
 * @param $group_type
 * @param $gid
 * @param $entity_type
 * @param $etid
 * @return mixed The OgMembership object if found, or FALSE.
 */
function og_get_membership($group_type, $gid, $entity_type, $etid) {
  $return = &drupal_static(__FUNCTION__, array());
  $identifier = $group_type . ':' . $gid . ':' . $entity_type . ':' . $etid;
  if (!isset($return[$identifier])) {
    $return[$identifier] = FALSE;

    $query = \Drupal::entityQuery('og_membership');
    $result = $query
        ->condition('gid', $gid, '=')
        ->condition('group_type', $group_type, '=')
        ->condition('etid', $etid, '=')
        ->condition('entity_type', $entity_type, '=')
        ->execute();

    if (!empty($result['og_membership'])) {
      $key = key($result['og_membership']);
      $return[$identifier] = $key;
    }
  }

  if (!empty($return[$identifier])) {
    $og_membership = og_membership_load($return[$identifier]);
    return $og_membership;
  }
  return FALSE;
}

/**
 * Invalidate cache.
 *
 * @param $gids
 *   Array with group IDs that their cache should be invalidated.
 */
function og_invalidate_cache($gids = array()) {
  // Reset static cache.
  $caches = array(
    'og_user_access',
    'og_user_access_alter',
    'og_role_permissions',
    'og_get_user_roles',
    'og_get_permissions',
    'og_get_group_audience_fields',
  );

  foreach ($caches as $cache) {
    drupal_static_reset($cache);
  }
  // Invalidate group membership cache.
  og_membership_invalidate_cache();

  // Let other OG modules know we invalidate cache.
  \Drupal::moduleHandler()->invokeAll('og_invalidate_cache', $gids);
}

/**
 * Get the groups an entity is associated with.
 *
 * @param $entity_type
 *   The entity type. Defaults to 'user'
 * @param $entity
 *   (optional) The entity object or entity ID. If empty, and $entity_type is
 *   "user", the current user will be used.
 * @param $states
 *   (optional) Array with the state to return. Defaults to active.
 *
 * @return
 *  An array with the group's entity type as the key, and array - keyed by
 *  the OG membership ID and the group ID as the value. If nothing found,
 *  then an empty array.
 */
function og_get_entity_groups($entity_type = 'user', $entity = NULL, $states = array(OG_STATE_ACTIVE)) {
  $cache = &drupal_static(__FUNCTION__, array());

  if ($entity_type == 'user' && empty($entity)) {
    global $user;
    $entity = clone $user;
  }
  if (is_object($entity)) {
    // Get the entity ID.
    $id = $entity->id();
  }
  else {
    $id = $entity;
  }

  // Get a string identifier of the states, so we can retrieve it from cache.
  if ($states) {
    sort($states);
    $state_identifier = implode(':', $states);
  }
  else {
    $state_identifier = 0;
  }

  if (isset($cache[$entity_type][$id][$state_identifier])) {
    // Return cached values.
    //return $cache[$entity_type][$id][$state_identifier];
  }

  $cache[$entity_type][$id][$state_identifier] = array();

  $query = Drupal::entityQuery('og_membership');
  $query
      ->condition('entity_type', $entity_type, '=')
      ->condition('etid', $id, '=');

  if ($states) {
    $query->condition('state', $states, 'IN');
  }

  $result = $query->execute();
  if (!empty($result)) {
    // Get the group ID from the group membership.
    $og_memberships = og_membership_load_multiple(array_keys($result));
    foreach ($og_memberships as $og_membership) {
      $cache[$entity_type][$id][$state_identifier][$og_membership->group_type()][$og_membership->id()] = $og_membership->gid();
    }
  }

  return $cache[$entity_type][$id][$state_identifier];
}

/**
 * Determine if a field is a group audience type.
 *
 * @param $entity_type
 *   The entity_type.
 * @param $field_name
 *   The field name.
 * @return boolean
 *   TRUE|FALSE
 */
function og_is_group_audience_field($entity_type, $field_name) {
  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  $settings = $field->getFieldSettings();
  return $field->getFieldType() == 'entity_reference' && ($settings['handler'] == 'og' || strpos($settings['handler'], 'og_') === 0);
}

/**
 * Get the name of the group-audience type field.
 *
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name to be checked.
 * @param $group_type
 *   Filter list to only include fields referencing a specific group type.
 * @param $group_bundle
 *   Filter list to only include fields referencing a specific group bundle.
 *   Fields that do not specify any bundle restrictions at all are also
 *   included.
 *
 * @return
 *   Array keyed with the field name and the field label as the value.
 */
function og_get_group_audience_fields($entity_type = 'user', $bundle_name = 'user', $group_type = NULL, $group_bundle = NULL) {
  $return = &drupal_static(__FUNCTION__, array());
  $identifier = $entity_type . ':' . $bundle_name . ':' . $group_type;
  if (isset($return[$identifier])) {
    return $return[$identifier];
  }
  $return[$identifier] = array();
  foreach (\Drupal\field\Field::fieldInfo()->getInstances($entity_type) as $key => $instances) {
    if ($key != $bundle_name) {
      continue;
    }
    foreach ($instances as $instance) {
      if (!og_is_group_audience_field($entity_type, $instance->getFieldName())) {
        continue;
      }

      $field_settings = $instance->getField()->getFieldSettings();
      if (isset($group_type) && $field_settings['target_type'] != $group_type) {
        continue;
      }
      if ($group_bundle && !empty($field_settings['handler_settings']['target_bundles']) && !in_array($group_bundle, $field_settings['handler_settings']['target_bundles'])) {
        continue;
      }
      $return[$identifier][$instance->getFieldName()] = $instance->getFieldLabel();
    }

  }

  return $return[$identifier];
}

/**
 * Return the group type (i.e. "group" or "group_content") of an entity.
 *
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name to be checked.
 * @param $type
 *   The group usage type. Must be "group" or "group content".
 *
 * @return boolean
 *   The group type or an "omitted" if node type doesn't participate in
 *   Group.
 */
function og_get_group_type($entity_type, $bundle_name, $type = 'group') {
  if ($type == 'group') {
    return (bool)\Drupal\field\Field::fieldInfo()->getInstance($entity_type, $bundle_name, OG_GROUP_FIELD);
  }
  elseif ($type == 'group content') {
    return (bool)og_get_group_audience_fields($entity_type, $bundle_name);
  }
}

/**
 * Return TRUE if the entity type is a "group" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $entity_type
 *   The entity type to be checked.
 *
 * @param $bundle_name
 *   The bundle name to be checked.
 * @return boolean
 *   TRUE|FALSE depending on whether or not the entity type is a "group" type.
 */
function og_is_group_type($entity_type, $bundle_name) {
  return og_get_group_type($entity_type, $bundle_name);
}

/**
 * Return TRUE if the entity type is a "group content" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $entity_type
 *   The entity type to be checked.
 * @param $bundle_name
 *
 * @return boolean
 */
function og_is_group_content_type($entity_type, $bundle_name) {
  return og_get_group_type($entity_type, $bundle_name, 'group content');
}

/**
 * Return all the entities that are a group content.
 *
 * @return array
 *   Array keyed with the entity type machine name and the entity human readable
 *   name as the value, or an empty array if no entities are defined as group
 *   content.
 */
function og_get_all_group_content_entity() {
  $return = array();

  foreach (Drupal::service('plugin.manager.entity')->getDefinitions() as $entity_type => $entity_value) {
    foreach ($entity_value['bundles'] as $bundle => $bundle_value) {
      if (og_is_group_content_type($entity_type, $bundle)) {
        $return[$entity_type] = check_plain($entity_value['label']);
        // At least one bundle of the entity can be a group, so break.
        break;
      }
    }
  }
  return $return;
}

/**
 * Return all bundles that are a group type.
 *
 * @return array
 *  An associative array whose keys are entity types, and whose values are
 *  arrays of bundles for that entity type. The array of bundles is keyed by
 *  bundle machine name, and the values are bundle labels.
 */
function og_get_all_group_bundle() {
  $return = array();

  foreach (Drupal::service('entity.manager')->getDefinitions() as $entity_type => $entity_value) {
    foreach (entity_get_bundles($entity_type) as $bundle => $bundle_value) {
      if (og_is_group_type($entity_type, $bundle)) {
        $return[$entity_type][$bundle] = check_plain($bundle_value['label']);
      }
    }
  }
  return $return;
}

/**
 * Return all the entities that are a group content.
 *
 * @return array
 *   Array keyed with the entity type machine name and the entity human readable
 *   name as the value, or an empty array if no entities are defined as group
 *   content.
 */
function og_get_all_group_content_bundle() {
  $return = array();

  foreach (entity_get_bundles() as $entity_type => $entity_value) {
    foreach ($entity_value as $bundle => $bundle_value) {
      if (og_is_group_content_type($entity_type, $bundle)) {
        $return[$entity_type][$bundle] = check_plain($bundle_value['label']);
      }
    }
  }
  return $return;
}

/**
 * Return TRUE if entity belongs to a group.
 *
 * @param $group_type
 *   The group type.
 * @param $gid
 *   The group ID.
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object. If empty the current user will be used.
 * @param $states
 *   (optional) Array with the state to return. If empty groups of all state will
 *   return.
 *
 * @return boolean
 *   TRUE if the entity (e.g. the user) belongs to a group and is not pending or
 *   blocked.
 */
function og_is_member($group_type, $gid, $entity_type = 'user', $entity = NULL, $states = array(OG_STATE_ACTIVE)) {
  $groups = og_get_entity_groups($entity_type, $entity, $states);
  return !empty($groups[$group_type]) && in_array($gid, $groups[$group_type]);
}

/**
 * Get all the modules fields that can be assigned to fieldable entities.
 *
 * @param $field_name
 *   The field name that was registered for the definition.
 *
 * @return array
 *   An array with the field and instance definitions, or FALSE if not
 *   found.
 */
function og_fields_info($field_name = NULL) {
  $return = &drupal_static(__FUNCTION__, array());

  if (empty($return)) {
    foreach (\Drupal::moduleHandler()->getImplementations('og_fields_info') as $module) {
      if ($fields = \Drupal::moduleHandler()->invoke($module, 'og_fields_info')) {
        foreach ($fields as $key => $field) {
          // Add default values.
          $field += array(
            'entity type' => array(),
            'multiple' => FALSE,
            'description' => '',
          );

          // Add the module information.
          $return[$key] = array_merge($field, array('module' => $module));
        }
      }
    }

    // Allow other modules to alter the field info.
    \Drupal::moduleHandler()->alter('og_fields_info', $return);
  }

  if (!empty($field_name)) {
    return !empty($return[$field_name]) ?  $return[$field_name] : FALSE;
  }

  return $return;
}

/**
 * Implements hook_og_fields_info().
 */
function og_og_fields_info() {
  $items[OG_GROUP_FIELD] = array(
    'type' => array('group'),
    'description' => t('Determine if this should be a group.'),
    'field' => array(
      'name' => OG_GROUP_FIELD,
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array(
        'allowed_values' => array(0 => 'Not a group', 1 => 'Group'),
        'allowed_values_function' => '',
      ),
    ),
    'instance' => array(
      'label' => t('Group'),
      'description' => t('Determine if this is an OG group.'),
      'display_label' => 1,
      'widget' => array(
        'module' => 'options',
        'settings' => array(
          'og_hide' => TRUE,
        ),
        'type' => 'options_onoff',
        'weight' => 0,
      ),
      'default_value' => array(0 => array('value' => 1)),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'og_group_subscribe',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'og_group_subscribe',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  $items[OG_DEFAULT_ACCESS_FIELD] = array(
    'type' => array('group'),
    'description' => t('Determine if group should use default roles and permissions.'),
    'field' => array(
      'name' => OG_DEFAULT_ACCESS_FIELD,
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array('allowed_values' => array(0 => 'Use default roles and permissions', 1 => 'Override default roles and permissions'), 'allowed_values_function' => ''),
    ),
    'instance' => array(
      'label' => t('Group roles and permissions'),
      'widget' => array(
        'module' => 'options',
        'settings' => array(),
        'type' => 'options_select',
      ),
      'required' => TRUE,
      // Use default role and permissions as default value.
      'default_value' => array(0 => array('value' => 0)),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'list_default',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'list_default',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  $items[OG_AUDIENCE_FIELD] = array(
    'multiple' => TRUE,
    'type' => array('group content'),
    'description' => t('Determine to which groups this group content is assigned to.'),
    'field' => array(
      'name' => OG_AUDIENCE_FIELD,
      'type' => 'entity_reference',
      'cardinality' => \Drupal\Core\Field\FieldDefinitionInterface::CARDINALITY_UNLIMITED,
      'active' => true,
      'settings' => array(
        'handler' => 'og',
        'handler_submit' => 'Change handler',
        'handler_settings' => array(
          'behaviors' => array(
            'og_behavior' => array(
              'status' => TRUE,
            ),
          ),
          'target_bundles' => array(),
          'membership_type' => OG_MEMBERSHIP_TYPE_DEFAULT,
        ),
        'target_type' => 'node',
      ),
    ),
    'instance' => array(
      'label' => t('Groups audience'),
      'widget' => array(
        'type' => 'og_complex',
        'module' => 'og',
        'settings' => array(),
      ),
      'settings' => array(
        'handler' => 'og',
        'handler_submit' => 'Change handler',
        'handler_settings' => array(
          'behaviors' => array(
            'og_behavior' => array(
              'status' => TRUE,
            ),
          ),
          'target_bundles' => array(),
          'membership_type' => OG_MEMBERSHIP_TYPE_DEFAULT,
        ),
        'behaviors' => array(
          'og_widget' => array(
            'status' => TRUE,
            'default' => array(
              'widget_type' => 'options_select',
            ),
            'admin' => array(
              'widget_type' => 'entity_reference_autocomplete',
            ),
          ),
        ),
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'og_list_default',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'og_list_default',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  return $items;
}

/**
 * Create an organic groups field in a bundle.
 *
 * @param $field_name
 *   The field name
 * @param $entity_type
 *   The entity type
 * @param $bundle
 *   The bundle name.
 * @param $og_field
 *   (optional) Array with field definitions, to allow easier overriding by the
 *   caller. If empty, function will get the field info by calling
 *   og_fields_info() with the field name.
 */
function og_create_field($field_name, $entity_type, $bundle, $og_field = array()) {
  if (empty($og_field)) {
    $og_field = og_fields_info($field_name);
  }

  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  // Allow overriding the field name.
  $og_field['field']['name'] = $field_name;
  // Allow overriding the entity type.
  $og_field['field']['entity_type'] = $entity_type;
  if (empty($field)) {
    $field =  $field = entity_create('field_entity', $og_field['field']);
    $field->save();
  }

  $instance = \Drupal\field\Field::fieldInfo()->getInstance($entity_type, $bundle, $field_name);
  if (empty($instance)) {
    $instance = $og_field['instance'];
    $instance += array(
      'field_name' => $field_name,
      'bundle' => $bundle,
      'entity_type' => $entity_type,
    );

    $instance = entity_create('field_instance', $instance);
    $instance->save();

    // Need to set widget independently from instance.
    entity_get_form_display($entity_type, $bundle, 'default')
      ->setComponent($field_name, $og_field['instance']['widget'])
      ->save();

    // Set view modes.
    foreach ($og_field['instance']['view modes'] as $view_mode => $settings) {
      entity_get_display('node', $bundle, $view_mode)
        ->setComponent($field_name, $settings)
        ->save();
    }

    // Clear the entity property info cache, as OG fields might add different
    // entity property info.
    og_invalidate_cache();
    entity_info_cache_clear();
  }
}

/**
 * Return the states a group can be in.
 */
function og_group_states() {
  return array(
    OG_STATE_ACTIVE => t('Active'),
    OG_STATE_PENDING => t('Pending'),
  );
}

/**
 * Return the states a group content can be in.
 */
function og_group_content_states() {
  return array(
    OG_STATE_ACTIVE => t('Active'),
    OG_STATE_PENDING => t('Pending'),
    OG_STATE_BLOCKED => t('Blocked'),
  );
}