<?php

/**
 * @file
 * Enable users to create and manage groups with roles and permissions.
 */

// Add field widget related code.
require DRUPAL_ROOT . '/' . drupal_get_path('module', 'og') . '/includes/og.field.inc';

/**
 * Define active group content states.
 *
 * When a user has this membership state they are considered to be of
 * "member" role.
 */
define('OG_STATE_ACTIVE', 1);

/**
 * Define pending group content states. The user is subscribed to the group
 * but isn't an active member yet.
 *
 * When a user has this membership state they are considered to be of
 * "non-member" role.
 */
define('OG_STATE_PENDING', 2);

/**
 * Define blocked group content states. The user is rejected from the group.
 *
 * When a user has this membership state they are denied access to any
 * group related action. This state, however, does not prevent user to
 * access a group or group content node.
 */
define('OG_STATE_BLOCKED', 3);

/**
 * Group audience field.
 */
define('OG_AUDIENCE_FIELD', 'og_group_ref');

/**
 * Group field.
 */
define('OG_GROUP_FIELD', 'group_group');

/**
 * Group default roles and permissions field.
 */
define('OG_DEFAULT_ACCESS_FIELD', 'og_roles_permissions');

/**
 * The role name of group non-members.
 */
define('OG_ANONYMOUS_ROLE', 'non-member');

/**
 * The role name of group member.
 */
define('OG_AUTHENTICATED_ROLE', 'member');

/**
 * The role name of group administrator.
 */
define('OG_ADMINISTRATOR_ROLE', 'administrator member');

/**
 * The default group membership type that is the bundle of group membership.
 */
define('OG_MEMBERSHIP_TYPE_DEFAULT', 'og_membership_type_default');

/**
 * The name of the user's request field in the default group membership type.
 */
define('OG_MEMBERSHIP_REQUEST_FIELD', 'og_membership_request');

/**
 * Implements hook_permission().
 */
function og_permission() {
  return array(
    'administer group' =>  array(
      'title' => t('Administer Organic groups permissions'),
      'description' => t('Administer all groups and permissions.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function og_menu() {
  $items = array();

  // Add our own autocomplete callback to pass also the group and
  // vocabulary info.
  $items['og/autocomplete/single/%/%/%/%'] = array(
    'title' => 'Entity Reference Autocomplete',
    'page callback' => 'og_entityreference_autocomplete_callback',
    'page arguments' => array(2, 3, 4, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['og/autocomplete/tags/%/%/%/%'] = array(
    'title' => 'Entity Reference Autocomplete',
    'page callback' => 'og_entityreference_autocomplete_callback',
    'page arguments' => array(2, 3, 4, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * OG membership type loader.
 *
 * @param $name
 *   (optional) The name for this membership type. If no type is given all existing
 *   types are returned.
 *
 * @return OgMembershipType
 *   Returns a fully-loaded membership type definition if a type name is passed.
 *   Else an array containing all types is returned.
 */
function og_membership_type_load($name = NULL) {
  // Replace dashes with underscores so this can be used as menu argument
  // loader too.
  $types = entity_load_multiple('og_membership_type', isset($name) ? array(strtr($name, array('-' => '_'))) : NULL);
  if (isset($name)) {
    return isset($types[$name]) ? $types[$name] : FALSE;
  }
  return $types;
}

/**
 * Reset static cache related to group membership.
 */
function og_membership_invalidate_cache() {
  $caches = array(
    'og_get_entity_groups',
    'og_get_membership',
    'og_get_field_og_membership_properties',
  );

  foreach ($caches as $cache) {
    drupal_static_reset($cache);
  }
}

/**
 * Determine if a field can be used and has not reached maximum values.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object or entity ID.
 * @param $field_name
 *   The group audience field name.
 * @return boolean
 *   TRUE|FALSE
 */
function og_check_field_cardinality($entity_type, $entity, $field_name) {
  $field = Field::fieldInfo()->getField($field_name);
  if ($field->getFieldCardinality() == FieldDefinitionInterface::CARDINALITY_UNLIMITED) {
    return TRUE;
  }

  if (is_numeric($entity)) {
    $entity = entity_load($entity_type, $entity);
  }

  return count($entity->getValue($field_name . '__og_membership')) < $field->getFieldCardinality();
}

/**
 * OG membership loader.
 *
 * @param $name
 *   (optional) The name for this group membership. If no type is given all existing
 *   types are returned.
 *
 * @return OgMembership
 *   Returns a fully-loaded group membership definition if a type name is passed.
 *   Else an array containing all types is returned.
 */
function og_membership_load($name = NULL) {
  return entity_load('og_membership', $name);
}

/**
 * Load multiple OG membership entities based on certain conditions.
 *
 * @param $ids
 *   An array of group membership IDs.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return array
 *   An array of group entities, indexed by group ID.
 */
function og_membership_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('og_membership', $ids, $conditions, $reset);
}

/**
 * Get the group membership entity by user and group.
 *
 * @param $group_type
 * @param $gid
 * @param $entity_type
 * @param $etid
 * @return mixed The OgMembership object if found, or FALSE.
 */
function og_get_membership($group_type, $gid, $entity_type, $etid) {
  $return = &drupal_static(__FUNCTION__, array());
  $identifier = $group_type . ':' . $gid . ':' . $entity_type . ':' . $etid;
  if (!isset($return[$identifier])) {
    $return[$identifier] = FALSE;

    $query = \Drupal::entityQuery('og_membership');
    $result = $query
        ->condition('gid', $gid, '=')
        ->condition('group_type', $group_type, '=')
        ->condition('etid', $etid, '=')
        ->condition('entity_type', $entity_type, '=')
        ->execute();

    if (!empty($result['og_membership'])) {
      $key = key($result['og_membership']);
      $return[$identifier] = $key;
    }
  }

  if (!empty($return[$identifier])) {
    $og_membership = og_membership_load($return[$identifier]);
    return $og_membership;
  }
  return FALSE;
}

/**
 * Invalidate cache.
 *
 * @param $gids
 *   Array with group IDs that their cache should be invalidated.
 */
function og_invalidate_cache($gids = array()) {
  // Reset static cache.
  $caches = array(
    'og_user_access',
    'og_user_access_alter',
    'og_role_permissions',
    'og_get_user_roles',
    'og_get_permissions',
    'og_get_group_audience_fields',
  );

  foreach ($caches as $cache) {
    drupal_static_reset($cache);
  }
  // Invalidate group membership cache.
  og_membership_invalidate_cache();

  // Let other OG modules know we invalidate cache.
  \Drupal::moduleHandler()->invokeAll('og_invalidate_cache', $gids);
}

/**
 * Get the groups an entity is associated with.
 *
 * @param $entity_type
 *   The entity type. Defaults to 'user'
 * @param $entity
 *   (optional) The entity object or entity ID. If empty, and $entity_type is
 *   "user", the current user will be used.
 * @param $states
 *   (optional) Array with the state to return. Defaults to active.
 *
 * @return
 *  An array with the group's entity type as the key, and array - keyed by
 *  the OG membership ID and the group ID as the value. If nothing found,
 *  then an empty array.
 */
function og_get_entity_groups($entity_type = 'user', $entity = NULL, $states = array(OG_STATE_ACTIVE)) {
  $cache = &drupal_static(__FUNCTION__, array());

  if ($entity_type == 'user' && empty($entity)) {
    global $user;
    $entity = clone $user;
  }
  if (is_object($entity)) {
    // Get the entity ID.
    $id = $entity->id();
  }
  else {
    $id = $entity;
  }

  // Get a string identifier of the states, so we can retrieve it from cache.
  if ($states) {
    sort($states);
    $state_identifier = implode(':', $states);
  }
  else {
    $state_identifier = 0;
  }

  if (isset($cache[$entity_type][$id][$state_identifier])) {
    // Return cached values.
    return $cache[$entity_type][$id][$state_identifier];
  }

  $cache[$entity_type][$id][$state_identifier] = array();

  $query = Drupal::entityQuery('og_membership');
  $query
      ->condition('entity_type', $entity_type, '=')
      ->condition('etid', $id, '=');

  if ($states) {
    $query->condition('state', $states, 'IN');
  }

  $result = $query->execute();
  if (!empty($result['og_membership'])) {
    // Get the group ID from the group membership.
    $og_memberships = og_membership_load_multiple(array_keys($result['og_membership']));
    foreach ($og_memberships as $og_membership) {
      $cache[$entity_type][$id][$state_identifier][$og_membership->group_type][$og_membership->id] = $og_membership->gid;
    }
  }

  return $cache[$entity_type][$id][$state_identifier];
}

/**
 * Determine if a field is a group audience type.
 *
 * @param $field_name
 *   The field name.
 * @return boolean
 *   TRUE|FALSE
 */
function og_is_group_audience_field($field_name) {
  $field = Field::fieldInfo()->getField($field_name);
  $settings = $field->getFieldSettings();
  return $field->getFieldType() == 'entity_reference' && ($settings['handler'] == 'og' || strpos($settings['handler'], 'og_') === 0);
}

/**
 * Get the name of the group-audience type field.
 *
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name to be checked.
 * @param $group_type
 *   Filter list to only include fields referencing a specific group type.
 * @param $group_bundle
 *   Filter list to only include fields referencing a specific group bundle.
 *   Fields that do not specify any bundle restrictions at all are also
 *   included.
 *
 * @return
 *   Array keyed with the field name and the field label as the value.
 */
function og_get_group_audience_fields($entity_type = 'user', $bundle_name = 'user', $group_type = NULL, $group_bundle = NULL) {
  $return = &drupal_static(__FUNCTION__, array());
  $identifier = $entity_type . ':' . $bundle_name . ':' . $group_type;
  if (isset($return[$identifier])) {
    return $return[$identifier];
  }
  $return[$identifier] = array();

  foreach (Field::fieldInfo()->getInstances($entity_type) as $key => $instance) {
    if ($key != $bundle_name) {
      continue;
    }
    if (!og_is_group_audience_field($instance->getFieldName)) {
      continue;
    }
    $field_settings = $instance->getField()->getFieldSettings();
    if (isset($group_type) && $field_settings['target_type'] != $group_type) {
      continue;
    }
    if ($group_bundle && !empty($field_settings['handler_settings']['target_bundles']) && !in_array($group_bundle, $field_settings['handler_settings']['target_bundles'])) {
      continue;
    }
    $return[$identifier][$instance->getFieldName()] = $instance->getFieldLabel();
  }
  return $return[$identifier];
}

/**
 * Return the group type (i.e. "group" or "group_content") of an entity.
 *
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name to be checked.
 * @param $type
 *   The group usage type. Must be "group" or "group content".
 *
 * @return boolean
 *   The group type or an "omitted" if node type doesn't participate in
 *   Group.
 */
function og_get_group_type($entity_type, $bundle_name, $type = 'group') {
  if ($type == 'group') {
    return (bool)\Drupal\field\Field::fieldInfo()->getInstance($entity_type, $bundle_name, OG_GROUP_FIELD);
  }
  elseif ($type == 'group content') {
    return (bool)og_get_group_audience_fields($entity_type, $bundle_name);
  }
}

/**
 * Return TRUE if the entity type is a "group" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $entity_type
 *   The entity type to be checked.
 *
 * @param $bundle_name
 *   The bundle name to be checked.
 * @return boolean
 *   TRUE|FALSE depending on whether or not the entity type is a "group" type.
 */
function og_is_group_type($entity_type, $bundle_name) {
  return og_get_group_type($entity_type, $bundle_name);
}

/**
 * Return all bundles that are a group type.
 *
 * @return array
 *  An associative array whose keys are entity types, and whose values are
 *  arrays of bundles for that entity type. The array of bundles is keyed by
 *  bundle machine name, and the values are bundle labels.
 */
function og_get_all_group_bundle() {
  $return = array();

  foreach (Drupal::service('entity.manager')->getDefinitions() as $entity_type => $entity_value) {
    foreach (entity_get_bundles($entity_type) as $bundle => $bundle_value) {
      if (og_is_group_type($entity_type, $bundle)) {
        $return[$entity_type][$bundle] = check_plain($bundle_value['label']);
      }
    }
  }
  return $return;
}

/**
 * Get all the modules fields that can be assigned to fieldable entities.
 *
 * @param $field_name
 *   The field name that was registered for the definition.
 *
 * @return array
 *   An array with the field and instance definitions, or FALSE if not
 *   found.
 */
function og_fields_info($field_name = NULL) {
  $return = &drupal_static(__FUNCTION__, array());

  if (empty($return)) {
    foreach (\Drupal::moduleHandler()->getImplementations('og_fields_info') as $module) {
      if ($fields = \Drupal::moduleHandler()->invoke($module, 'og_fields_info')) {
        foreach ($fields as $key => $field) {
          // Add default values.
          $field += array(
            'entity type' => array(),
            'multiple' => FALSE,
            'description' => '',
          );

          // Add the module information.
          $return[$key] = array_merge($field, array('module' => $module));
        }
      }
    }

    // Allow other modules to alter the field info.
    \Drupal::moduleHandler()->alter('og_fields_info', $return);
  }

  if (!empty($field_name)) {
    return !empty($return[$field_name]) ?  $return[$field_name] : FALSE;
  }

  return $return;
}

/**
 * Implements hook_og_fields_info().
 */
function og_og_fields_info() {
  $items[OG_GROUP_FIELD] = array(
    'type' => array('group'),
    'description' => t('Determine if this should be a group.'),
    'field' => array(
      'name' => OG_GROUP_FIELD,
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array(
        'allowed_values' => array(0 => 'Not a group', 1 => 'Group'),
        'allowed_values_function' => '',
      ),
    ),
    'instance' => array(
      'label' => t('Group'),
      'description' => t('Determine if this is an OG group.'),
      'display_label' => 1,
      'widget' => array(
        'module' => 'options',
        'settings' => array(
          'og_hide' => TRUE,
        ),
        'type' => 'options_onoff',
        'weight' => 0,
      ),
      'default_value' => array(0 => array('value' => 1)),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'og_group_subscribe',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'og_group_subscribe',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  $items[OG_DEFAULT_ACCESS_FIELD] = array(
    'type' => array('group'),
    'description' => t('Determine if group should use default roles and permissions.'),
    'field' => array(
      'name' => OG_DEFAULT_ACCESS_FIELD,
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array('allowed_values' => array(0 => 'Use default roles and permissions', 1 => 'Override default roles and permissions'), 'allowed_values_function' => ''),
    ),
    'instance' => array(
      'label' => t('Group roles and permissions'),
      'widget' => array(
        'module' => 'options',
        'settings' => array(),
        'type' => 'options_select',
      ),
      'required' => TRUE,
      // Use default role and permissions as default value.
      'default_value' => array(0 => array('value' => 0)),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'list_default',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'list_default',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  $items[OG_AUDIENCE_FIELD] = array(
    'multiple' => TRUE,
    'type' => array('group content'),
    'description' => t('Determine to which groups this group content is assigned to.'),
    'field' => array(
      'name' => OG_AUDIENCE_FIELD,
      'type' => 'entity_reference',
      'cardinality' => \Drupal\Core\Field\FieldDefinitionInterface::CARDINALITY_UNLIMITED,
      'active' => true,
      'settings' => array(
        'handler' => 'og',
        'handler_submit' => 'Change handler',
        'handler_settings' => array(
          'behaviors' => array(
            'og_behavior' => array(
              'status' => TRUE,
            ),
          ),
          'target_bundles' => array(),
          'membership_type' => OG_MEMBERSHIP_TYPE_DEFAULT,
        ),
        'target_type' => 'node',
      ),
    ),
    'instance' => array(
      'label' => t('Groups audience'),
      'widget' => array(
        'type' => 'og_complex',
        'module' => 'og',
        'settings' => array(),
      ),
      'settings' => array(
        'handler' => 'og',
        'handler_submit' => 'Change handler',
        'handler_settings' => array(
          'behaviors' => array(
            'og_behavior' => array(
              'status' => TRUE,
            ),
          ),
          'target_bundles' => array(),
          'membership_type' => OG_MEMBERSHIP_TYPE_DEFAULT,
        ),
        'behaviors' => array(
          'og_widget' => array(
            'status' => TRUE,
            'default' => array(
              'widget_type' => 'options_select',
            ),
            'admin' => array(
              'widget_type' => 'entity_reference_autocomplete',
            ),
          ),
        ),
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'og_list_default',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'og_list_default',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  return $items;
}

/**
 * Create an organic groups field in a bundle.
 *
 * @param $field_name
 *   The field name
 * @param $entity_type
 *   The entity type
 * @param $bundle
 *   The bundle name.
 * @param $og_field
 *   (optional) Array with field definitions, to allow easier overriding by the
 *   caller. If empty, function will get the field info by calling
 *   og_fields_info() with the field name.
 */
function og_create_field($field_name, $entity_type, $bundle, $og_field = array()) {
  if (empty($og_field)) {
    $og_field = og_fields_info($field_name);
  }

  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  // Allow overriding the field name.
  $og_field['field']['name'] = $field_name;
  // Allow overriding the entity type.
  $og_field['field']['entity_type'] = $entity_type;
  if (empty($field)) {
    $field =  $field = entity_create('field_entity', $og_field['field']);
    $field->save();
  }

  $instance = \Drupal\field\Field::fieldInfo()->getInstance($entity_type, $bundle, $field_name);
  if (empty($instance)) {
    $instance = $og_field['instance'];
    $instance += array(
      'field_name' => $field_name,
      'bundle' => $bundle,
      'entity_type' => $entity_type,
    );

    $instance = entity_create('field_instance', $instance);
    $instance->save();

    // Need to set widget independently from instance.
    entity_get_form_display($entity_type, $bundle, 'default')
      ->setComponent($field_name, $og_field['instance']['widget'])
      ->save();

    // Set view modes.
    foreach ($og_field['instance']['view modes'] as $view_mode => $settings) {
      entity_get_display('node', $bundle, $view_mode)
        ->setComponent($field_name, $settings)
        ->save();
    }

    // Clear the entity property info cache, as OG fields might add different
    // entity property info.
    og_invalidate_cache();
    entity_info_cache_clear();
  }
}