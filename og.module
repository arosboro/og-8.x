<?php

/**
 * @file
 * Enable users to create and manage groups with roles and permissions.
 */

// Add field widget related code.
require DRUPAL_ROOT . '/' . drupal_get_path('module', 'og') . '/includes/og.field.inc';

/**
 * Define active group content states.
 *
 * When a user has this membership state they are considered to be of
 * "member" role.
 */
define('OG_STATE_ACTIVE', 1);

/**
 * Define pending group content states. The user is subscribed to the group
 * but isn't an active member yet.
 *
 * When a user has this membership state they are considered to be of
 * "non-member" role.
 */
define('OG_STATE_PENDING', 2);

/**
 * Define blocked group content states. The user is rejected from the group.
 *
 * When a user has this membership state they are denied access to any
 * group related action. This state, however, does not prevent user to
 * access a group or group content node.
 */
define('OG_STATE_BLOCKED', 3);

/**
 * Group audience field.
 */
define('OG_AUDIENCE_FIELD', 'og_group_ref');

/**
 * Group field.
 */
define('OG_GROUP_FIELD', 'group_group');

/**
 * Group default roles and permissions field.
 */
define('OG_DEFAULT_ACCESS_FIELD', 'og_roles_permissions');

/**
 * The role name of group non-members.
 */
define('OG_ANONYMOUS_ROLE', 'non-member');

/**
 * The role name of group member.
 */
define('OG_AUTHENTICATED_ROLE', 'member');

/**
 * The role name of group administrator.
 */
define('OG_ADMINISTRATOR_ROLE', 'administrator member');

/**
 * The default group membership type that is the bundle of group membership.
 */
define('OG_MEMBERSHIP_TYPE_DEFAULT', 'og_membership_type_default');

/**
 * The name of the user's request field in the default group membership type.
 */
define('OG_MEMBERSHIP_REQUEST_FIELD', 'og_membership_request');

/**
 * Implements hook_permission().
 */
function og_permission() {
  return array(
    'administer group' =>  array(
      'title' => t('Administer Organic groups permissions'),
      'description' => t('Administer all groups and permissions.'),
    ),
  );
}

/**
 * Implements hook_og_permission().
 */
function og_og_permission() {
  // Generate standard node permissions for all applicable node types.
  $perms = array();

  $perms['update group'] = array(
    'title' => t('Edit group'),
    'description' => t('Edit the group. Note: This permission controls only node entity type groups.'),
    'default role' => array(OG_ADMINISTRATOR_ROLE),
  );
  $perms['administer group'] = array(
    'title' => t('Administer group'),
    'description' => t('Manage group members and content in the group.'),
    'default role' => array(OG_ADMINISTRATOR_ROLE),
    'restrict access' => TRUE,
  );

  foreach (node_permissions_get_configured_types() as $type) {
    $perms = array_merge($perms, og_list_permissions($type->type));
  }

  return $perms;
}


/**
 * Implements hook_og_default_roles().
 */
function og_og_default_roles() {
  return array(OG_ADMINISTRATOR_ROLE);
}

/**
 * Implements hook_menu().
 */
function og_menu() {
  $items = array();

  // Add our own autocomplete callback to pass also the group and
  // vocabulary info.
  $items['og/autocomplete/single/%/%/%/%'] = array(
    'title' => 'Entity Reference Autocomplete',
    'page callback' => 'og_entityreference_autocomplete_callback',
    'page arguments' => array(2, 3, 4, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['og/autocomplete/tags/%/%/%/%'] = array(
    'title' => 'Entity Reference Autocomplete',
    'page callback' => 'og_entityreference_autocomplete_callback',
    'page arguments' => array(2, 3, 4, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function og_entity_info() {
  $items['og_membership_type'] = array(
    'label' => t('OG membership type'),
    'controller class' => 'EntityAPIControllerExportable',
    'entity class' => 'OgMembershipType',
    'base table' => 'og_membership_type',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'description',
      'name' => 'name',
    ),
    'exportable' => TRUE,
    'export' => array(
      'default hook' => 'default_og_membership_type',
    ),
    'bundle of' => 'og_membership',
    'module' => 'og',
    'metadata controller class' => 'EntityDefaultMetadataController',
    'views controller class' => 'EntityDefaultViewsController',
    'access callback' => 'og_membership_type_access',
    'entity cache' => module_exists('entitycache'),
  );

  if (class_exists('OgMembershipTypeUIController')) {
    $items['og_membership_type'] += array(
      // Enable the entity API's admin UI.
      'admin ui' => array(
        // TODO: This path doesn't exist before OG-ui.
        'path' => 'admin/config/group/group-membership',
        'file' => 'includes/og.admin.inc',
        'controller class' => 'OgMembershipTypeUIController',
      ),
    );
  }

  $items['og_membership'] = array(
    'label' => t('OG membership'),
    'entity class' => 'OgMembership',
    'controller class' => 'EntityAPIController',
    'base table' => 'og_membership',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      // The message has no label.
      'label' => FALSE,
      'bundle' => 'type',
    ),
    'label callback' => 'og_membership_label',
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'name',
    ),
    'module' => 'og',
    'metadata controller class' => 'OgMembershipMetadataController',
    'views controller class' => 'OgMembershipViewsController',
    'access callback' => 'og_membership_access',
//    'entity cache' => \Drupal::moduleHandler()->moduleExists(entitycache),
  );

  // Add bundle info but bypass entity_load() as we cannot use it here.
  if (db_table_exists('og_membership_type')) {
    $memberships = db_select('og_membership_type', 'g')
        ->fields('g')
        ->execute()
        ->fetchAllAssoc('name');

    foreach ($memberships as $type_name => $type) {
      $items['og_membership']['bundles'][$type_name] = array(
        'label' => $type->name,
        'admin' => array(
          'path' => 'admin/config/group/group-membership/manage/%og_membership_type',
          'real path' => 'admin/config/group/group-membership/manage/' . $type->name,
          'bundle argument' => 5,
          'access arguments' => array('administer group'),
        ),
      );
    }
  }

  return $items;
}

/**
 * Implements hook_entity_field_info().
 */
function og_entity_field_info($entity_type) {
  $info = array();
  return;

  // Add OG membership metadata for every bundle that is a group content.
  foreach (og_get_all_group_content_bundle() as $entity_type => $bundles) {
    foreach ($bundles as $bundle => $bundle_value) {
      $info['optional']['og_membership'] = array(
        'label' => t("OG memberships"),
        'type' => 'og_membership',
        'list' => TRUE,
        'description' => t("A list of all OG memberships of the @name entity.", array('@name' => $entity_type)),
        'getter callback' => 'og_get_og_membership_properties',
        'class' => '\Drupal\og\Entity\OgMembership',
      );
      $info['bundle map'][$bundle][] = 'og_membership';

      // Add per-state properties.
      $general = $info['optional']['og_membership'];
      foreach (og_group_content_states() as $state => $state_label) {
        $params = array('@state' => $state_label, '@name' => $entity_type);
        $info['optional']['og_membership__' . $state] = $general;
        $info['optional']['og_membership__' . $state]['label'] = t('@state OG membership', $params);
        $info['optional']['og_membership__' . $state]['description'] = t("A list of all OG memberships of the @name entity with @state state.", $params);
        $info['bundle map'][$bundle][] = 'og_membership__' . $state;
      }

      // Add OG membership per field in a bundle.
      foreach (og_get_group_audience_fields($entity_type, $bundle) as $field_name => $label) {
        $params = array('@label' => $label);
        $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
        $field_settings = $field->getFieldSettings();
        $group_type = $field_settings['target_type'];
        $info['optional'][$field_name . '__og_membership'] = array(
          'label' => t('OG membership from field @label', $params),
          'type' => 'og_membership',
          'list' => TRUE,
          // The bundle in this context means the OG membership type.
          'bundle' => $field_settings['handler_settings']['membership_type'],
          'description' => t('A list of all OG memberships registered in field @label.', $params),
          'getter callback' => 'og_get_field_og_membership_properties',
          'class' => '\Drupal\og\Entity\OgMembership',
        );
        $info['bundle map'][$bundle][] = $field_name . '__og_membership';

        // Add per-state properties.
        $general = $info['optional'][$field_name . '__og_membership'];
        foreach (og_group_content_states() as $state => $state_label) {
          $params = array(
            '@label' => $label,
            '@label' => $label,
            '@state' => $state_label,
          );
          $info['optional'][$field_name . '__og_membership__' . $state] = $general;
          $info['optional'][$field_name . '__og_membership__' . $state]['label'] = t('@state OG memberships from field @label', $params);
          $info['optional'][$field_name . '__og_membership__' . $state]['description'] = t('A list of all OG memberships with @state registered in field @label.', $params);
          $info['bundle map'][$bundle][] = $field_name . '__og_membership';
        }
      }
    }
  }

  foreach (og_get_all_group_bundle() as $entity_type => $bundles) {
    foreach ($bundles as $bundle => $bundle_value) {
      $info['optional']['members'] = array(
        'label' => t("Group members"),
        'type' => 'user',
        'list' => TRUE,
        'description' => t("A list group members of the @name entity.", array('@name' => $entity_type)),
        'getter callback' => 'og_get_group_members_properties',
        'class' => '\Drupal\user\Entity\User',
      );
      $info['bundle map'][$bundle][] = 'members';

      // Add per-state properties.
      $general = $info['optional']['members'];
      foreach (og_group_content_states() as $state => $state_label) {
        $params = array('@state' => $state_label, '@name' => $entity_type);
        $info['optional']['members__' . $state] = $general;
        $info['optional']['members__' . $state]['label'] = t('@state group members', $params);
        $info['optional']['members__' . $state]['description'] = t("A list of all users of the @name entity with @state state.", $params);
        $info['bundle map'][$bundle][] = 'members__' . $state;
      }
    }
  }

  return $info;
}

/**
 * Property getter callback for group members.
 *
 * @see og_entity_property_info()
 */
function og_get_group_members_properties($entity, array $options, $name, $type) {
  $args = explode('__', $name);
  $state = !empty($args[1]) ? $args[1] : FALSE;
  $id = $entity->id();

  $cache = &drupal_static(__FUNCTION__, array());
  if (isset($cache[$type][$id][$state])) {
    // Return the cached result.
    return $cache[$type][$id][$state];
  }
  $cache[$type][$id][$state] = array();

  $query = \Drupal::entityQuery('og_membership');
  $query
      ->condition('group_type', $type, '=')
      ->condition('gid', $id, '=')
      ->condition('entity_type', 'user', '=');

  if ($state) {
    $query->condition('state', $state, '=');
  }

  $result = $query->execute();
  if (!empty($result['og_membership'])) {
    $og_memberships = og_membership_load_multiple(array_keys($result['og_membership']));
    foreach ($og_memberships as $og_membership) {
      $cache[$type][$id][$state][] = $og_membership->etid;

    }
  }
  return $cache[$type][$id][$state];
}

/**
 * Property getter callback for OG membership.
 *
 * @see og_entity_property_info()
 */
function og_get_og_membership_properties($entity, array $options, $name, $type) {
  // Get the state from name, if exists.
  if ($name == 'og_membership') {
    $state = array();
  }
  else {
    $args = explode('__', $name);
    $state = array($args[1]);
  }

  $ids = array();

  if ($gids = og_get_entity_groups($type, $entity, $state)) {
    $ids = array();
    foreach ($gids as $group_type => $values) {
      $ids = array_merge($ids, array_keys($values));
    }
  }

  return $ids;
}

/**
 * Property getter callback for OG membership per field.
 *
 * @see og_entity_property_info()
 */
function og_get_field_og_membership_properties($entity, array $options, $name, $type) {
  $args = explode('__', $name);
  // Field name might have double underscore as-well, so we need to make
  // sure we get it right.
  $last_char = substr($name, -1);
  $state = is_numeric($last_char) ? $last_char : FALSE;

  // The number of characters to ignore in the name (i.e. remove the
  // "__og_membership" or "__og_membership__0").
  $remove_char = $state ? -18 : -15;
  $field_name = substr($name, 0, $remove_char);

  $field_name = $args[0];
  $state = count($args) == 2 ? FALSE : $args[2];
  $id = $entity->id();

  $identifier = $type . ':' . $id . ':' . $field_name . ':' . $state;
  $cache = &drupal_static(__FUNCTION__, array());
  if (isset($cache[$identifier])) {
    // Return the cached result.
    return $cache[$identifier];
  }

  $query = \Drupal::entityQuery('og_membership');
  $query
      ->condition('entity_type', $type, '=')
      ->condition('etid', $id, '=')
      ->condition('field_name', $field_name, '=');

  if ($state) {
    $query->condition('state', $state, '=');
  }

  $result = $query->execute();
  $cache[$identifier] = !empty($result['og_membership']) ? array_keys($result['og_membership']) : array();
  return $cache[$identifier];
}

/**
 * Implements hook_field_create_instance().
 *
 * - Create default OG roles per entity-type and bundle.
 * - Create a group audience field on the user's entity, referencing the first
 *   group defined.
 */
function og_field_create_instance($entity) {
  if ($entity->getFieldName() != OG_GROUP_FIELD) {
    return;
  }

  // Create default roles per entity-type per bundle.
  og_roles_override($entity->entity_type, $entity->bundle, 0);

  // Check if we need to add a group audience on the user's entity.
  // We add a different field, so each field can be set differently.
  $entity_type = $entity->entity_type;
  $bundle = $entity->bundle;

  foreach (array_keys(og_get_group_audience_fields()) as $field_name) {
    $field = \Drupal\field\Field::fieldInfo()->getField('user', $field_name);

    $settings = $field->getFieldSettings();
    if ($settings['target_type'] == $entity_type  && empty($settings['handler_settings']['target_bundles'])) {
      return;
    }

    if ($settings['target_type'] == $entity_type && in_array($bundle, $settings['handler_settings']['target_bundles'])) {
      return;
    }
  }

  // If we reached here, it means we need to create a field.
  // Pick an unused name.
  $field_name = substr("og_user_$entity_type", 0, 32);
  $i = 1;
  while (\Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name)) {
    $field_name = substr("og_user_$entity_type", 0, 32 - strlen($i)) . $i;
    ++$i;
  }

  $og_field = og_fields_info(OG_AUDIENCE_FIELD);
  $og_field['field']['settings']['target_type'] = $entity_type;
  $og_field['instance']['label'] = t('Group membership');

  // If the user entity type has multiple bundles, make sure to attach a field
  // entity to all of them.
  $entity_bundles = entity_get_bundles('user');
  foreach ($entity_bundles as $user_bundle => $bundle_info) {
    og_create_field($field_name, 'user', $user_bundle, $og_field);
  }
}

/**
 * Implements field_delete_instance().
 *
 * - Invalidate OG's static cache if a group-audience field is deleted.
 * - Delete the default OG roles per entity-type and bundle.
 */
function og_field_delete_instance($entity) {
  if (og_is_group_audience_field($entity->entity_type, $entity->getFieldName())) {
    og_invalidate_cache();
  }

  if ($entity->getFieldName() != OG_GROUP_FIELD) {
    return;
  }

  // Get the per-bundle roles.
  $roles = og_roles($entity->entityType(), $entity->bundle());
  foreach ($roles as $rid => $name) {
    og_role_delete($rid);
  }
}

/**
 * Implements hook_entity_insert().
 */
function og_entity_insert(\Drupal\Core\Entity\EntityInterface $entity) {
  // React when different types of entities are created.
  switch ($entity->entityType()) {
    case 'field_instance':
      og_field_create_instance($entity);
      break;

    default:
      break;
  }

  if (!og_is_group($entity)) {
    return;
  }
  $id = $entity->id();
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();

  if ($entity_type == 'node' && $uid = $entity->getAuthorId() && !empty($uid) || $entity_type == 'user' && $uid = $entity->id()) {
    // Subscribe the group manager.
    og_group($entity_type, $id, array('entity' => $uid));
    // Assign roles to group manager.
    $name = 'group_manager_default_rids.' . $entity_type . '.' . $bundle;
    if ($rids = \Drupal::Config('og.settings')->get($name)) {
      foreach ($rids as $rid) {
        og_role_grant($entity_type, $id, $entity->getAuthorId(), $rid);
      }
    }
  }

  if (!og_is_group_default_access($entity_type, $entity)) {
    // Override default roles.
    og_roles_override($entity_type, $bundle, $id);
  }
}

/**
 * Implements hook_entity_update().
 */
function og_entity_update(\Drupal\Core\Entity\EntityInterface $entity) {
  if (!og_is_group($entity)) {
    return;
  }

  $id = $entity->id();
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();
  $uid = ($entity_type == 'node') ? $entity->getAuthorId() : (($entity_type == 'user') ? $entity->id() : 0);
  if (!empty($uid) && !og_is_member($entity_type, $id, 'user', $uid)) {
    // Subscribe the group manager, in case the owner changed.
    og_group($entity_type, $id, array('entity' => $uid));
    // Assign roles to group manager.
    // TODO roles
    $name = 'og_group_manager_default_rids_' . $entity_type . '_' . $bundle;
    if ($rids = variable_get($name)) {
      foreach ($rids as $rid) {
        og_role_grant($entity_type, $id, $entity->uid, $rid);
      }
    }
  }
  $original_entity = $entity->original;
  $property = OG_DEFAULT_ACCESS_FIELD;

  if (!empty($entity->{$property}) && $entity->{$property} != $original_entity->{$property}) {
    if (!og_is_group_default_access($entity_type, $entity)) {
      // Override default roles.
      og_roles_override($entity_type, $bundle, $id);
    }
    else {
      // Delete overridden roles.
      og_delete_user_roles_by_group($entity_type, $entity);
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function og_entity_delete(\Drupal\Core\Entity\EntityInterface $entity) {
  // React when different types of entities are created.
  switch ($entity->entityType()) {
    case 'field_instance':
      og_field_delete_instance($entity);
      break;

    default:
      break;
  }
}

/**
 * Implements hook_field_storage_pre_insert().
 */
function og_field_storage_pre_insert(\Drupal\Core\Entity\EntityInterface $entity, $skip_fields) {
  _og_update_entity_fields($entity, $skip_fields);
}

/**
 * Implements hook_field_storage_pre_update().
 */
function og_field_storage_pre_update(\Drupal\Core\Entity\EntityInterface$entity, $skip_fields) {
  _og_update_entity_fields($entity, $skip_fields);
}

/**
 * Update the field values in the entity, to reflect the membership.
 *
 * This is used to allow other modules that save a new/ existing entity
 * to act on the field values, even before hook_field_load() is called.
 */
function _og_update_entity_fields(\Drupal\Core\Entity\EntityInterface $entity, $skip_fields) {
  $id = $entity->id();
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();
  if (!og_is_group_content_type($entity_type, $bundle)) {
    return;
  }

  foreach (og_get_group_audience_fields($entity_type, $bundle) as $field_name => $label) {
    $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);;
    $gids = array();
    if ($field['cardinality'] == 1) {
      if ($og_membership = $field->getValue($field_name . '__og_membership')) {
        // Wrapper return an array.
        $gids = $og_membership[0]->gid;
      }
    }
    else {
      foreach ($field->getValue($field_name . '__og_membership') as $og_membership) {
        $gids[] = $og_membership->gid;
      }
    }
    if ($gids) {
      $field->setValue($gids);
    }
  }
}

/**
 * OG membership type loader.
 *
 * @param $name
 *   (optional) The name for this membership type. If no type is given all existing
 *   types are returned.
 *
 * @return OgMembershipType
 *   Returns a fully-loaded membership type definition if a type name is passed.
 *   Else an array containing all types is returned.
 */
function og_membership_type_load($name = NULL) {
  // Replace dashes with underscores so this can be used as menu argument
  // loader too.
  $types = entity_load_multiple('og_membership_type', isset($name) ? array(strtr($name, array('-' => '_'))) : NULL);
  if (isset($name)) {
    return isset($types[$name]) ? $types[$name] : FALSE;
  }
  return $types;
}

/**
 * Reset static cache related to group membership.
 */
function og_membership_invalidate_cache() {
  $caches = array(
    'og_get_entity_groups',
    'og_get_membership',
    'og_get_field_og_membership_properties',
  );

  foreach ($caches as $cache) {
    drupal_static_reset($cache);
  }
}

/**
 * Return TRUE if the entity is acting as a group.
 *
 * @param $entity
 *   The entity object, or the entity ID.
 *
 * @return boolean
 */
function og_is_group(\Drupal\Core\Entity\EntityInterface $entity) {
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();

  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, OG_GROUP_FIELD);
  if (!$field) {
// TODO make config entity
    return;
//    return variable_get("og_is_group__{$entity_type}__{$bundle}", FALSE);
  }

  $value = $entity->{OG_GROUP_FIELD}->value;
  return !empty($value);
}

/**
 * Get the first best matching group-audience field.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object.
 * @param $group_type
 *   The group type.
 * @param $group_bundle
 *   The group bundle.
 * @param $skip_access
 *   TRUE, if current user access to the field, should be skipped.
 *   Defaults to FALSE.
 *
 * @return string
 *   Field name of the group audience field.
 */
function og_get_best_group_audience_field($entity_type, $entity, $group_type, $group_bundle, $skip_access = FALSE) {
  $bundle = $entity->bundle();

  $field_names = og_get_group_audience_fields($entity_type, $bundle);
  if (!$field_names) {
    return;
  }
  foreach ($field_names as $field_name => $label) {
    $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
    $settings = $field->getFieldSettings();
    if ($settings['target_type'] != $group_type) {
      // Group type doesn't match.
      continue;
    }
    if (!empty($settings['handler_settings']['target_bundles']) && !in_array($group_bundle, $settings['handler_settings']['target_bundles'])) {
      // Bundles don't match.
      continue;
    }


    if (!og_check_field_cardinality($entity_type, $entity, $field_name)) {
      // Field reached maximum.
      continue;
    }

    if (!$skip_access && !field_access('view', $field, $entity_type, $entity)) {
      // User can't access field.
      continue;
    }

    return $field_name;
  }
}


/**
 * Determine if a field can be used and has not reached maximum values.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object or entity ID.
 * @param $field_name
 *   The group audience field name.
 * @return boolean
 *   TRUE|FALSE
 */
function og_check_field_cardinality($entity_type, $entity, $field_name) {
  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  if ($field->getFieldCardinality() == \Drupal\Core\Field\FieldDefinitionInterface::CARDINALITY_UNLIMITED) {
    return TRUE;
  }

  if (is_numeric($entity)) {
    $entity = entity_load($entity_type, $entity);
  }

  return count($entity->getValue($field_name . '__og_membership')) < $field->getFieldCardinality();
}

/**
 * Set an association (e.g. subscribe) an entity to a group.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group entity or ID.
 * @param $values
 *   Array with the information to pass along, until it is processed in the
 *   field handlers.
 *   - "entity_type": (optional) The entity type (e.g. "node" or "user").
 *     Defaults to 'user'
 *   - "entity": (optional) The entity object or entity Id to set the
 *     association. Defaults to the current user if the $entity_type property is
 *     set to 'user'.
 *   - "field_name": The name of the field, the membership should be registered
 *     in. If no value given, a first field with the correct membership type
 *     will be used. If no field found, an execpetion will be thrown.
 * @param $save_created
 *    (optional) If the OG membership is new, it determines whether the
 *    membership will be saved. Defaults to TRUE.
 *
 * @throws \Drupal\og\OgException
 *   When a group audience field cannot be found.
 *
 * @return \Drupal\og\Entity\OgMembership
 *   The OG membership entity.
 */
function og_group($group_type, $gid, $values = array(), $save_created = TRUE) {
  global $user;
  // Set default values.
  $values += array(
    'entity_type' => 'user',
    'entity' => FALSE,
    'field_name' => FALSE,
    'state' => OG_STATE_ACTIVE,
  );

  $entity_type = $values['entity_type'];
  $entity = $values['entity'];
  $field_name = $values['field_name'];
  $state = $values['state'];

  if ($entity_type == 'user' && empty($entity)) {
    $entity = $user->id();
  }

  // If entity was an ID, get the object.
  $entity = entity_load($entity_type, $entity);
  $bundle = $entity->bundle();
  $id = $entity->id();

  if (is_object($gid)) {
    $group = $gid;

  }
  else {
    $group = entity_load($group_type, $gid);
  }

  // the group ID might be the entity, so re-populate it.
  $gid = $group->id();
  $group_bundle = $group->bundle();

  // Get membership if exists.
  $og_membership = og_get_membership($group_type, $gid, $entity_type, $id);

  if (!$og_membership && empty($field_name)) {
    $params = array(
      '%entity-type' => $entity_type,
      '%bundle' => $bundle,
      '%group-type' => $group_type,
      '%group-bundle' => $group_bundle,
    );

    // Allow getting fields not accessible by the user.
    $field_name = og_get_best_group_audience_field($entity_type, $entity, $group_type, $group_bundle, TRUE);
    if (!$field_name) {
      throw new \Drupal\og\OgException(format_string('There are no OG fields in entity %entity-type and bundle %bundle referencing %group-type - %group-bundle.', $params));
    }
  }

  if ($og_membership) {
    if (empty($og_membership->is_new) && $og_membership->field_name == $field_name && $og_membership->state == $state) {
      // Entity is already associated with group.
      return $og_membership;
    }
    elseif (!empty($field_name) && $og_membership->field_name != $field_name) {
      // Ungroup the current association, as it needs to change field.
      og_ungroup($group_type, $gid, $entity_type, $id);
      $og_membership = FALSE;
    }
    elseif ($og_membership->state != $state){
      // Change the state.
      $og_membership->state = $state;
    }
    else {
      // Nothing changed.
      return $og_membership;
    }
  }

  if (!$og_membership) {
    // Unset the values, so we don't try to process them.
    unset($values['entity_type'], $values['entity'], $values['field_name']);
    // Create a new OG membership.
    $og_membership = og_membership_create($group_type, $gid, $entity_type, $id, $field_name, $values);
  }

  if (empty($og_membership->is_new) || $save_created) {
    // Save the membership for update, or if the OG membership is new when
    // "save-created" is TRUE.
    $og_membership->save();
  }

  return $og_membership;
}

/**
 * Determine whether a user has a given privilege.
 *
 * All permission checks in OG should go through this function. This
 * way, we guarantee consistent behavior, and ensure that the superuser
 * and group administrators can perform all actions.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The entity ID of the group.
 * @param $string
 *   The permission, such as "administer group", being checked for.
 * @param $account
 *   (optional) The account to check. Defaults to the current user.
 * @param $skip_alter
 *   (optional) If TRUE then user access will not be sent to other modules
 *   using drupal_alter(). This can be used by modules implementing
 *   hook_og_user_access_alter() that still want to use og_user_access(), but
 *   without causing a recursion. Defaults to FALSE.
 * @param $ignore_admin
 *   (optional) When TRUE the specific permission is checked, ignoring the
 *   "administer group" permission if the user has it. When FALSE, a user
 *   with "administer group" will be granted all permissions.
 *   Defaults to FALSE.
 *
 * @return boolean
 *   TRUE or FALSE if the current user has the requested permission.
 *   NULL, if the given group isn't a valid group.
 */
function og_user_access($group_type, $gid, $string, \Drupal\Core\Session\AccountInterface $account = NULL, $skip_alter = FALSE, $ignore_admin = FALSE) {
  global $user;
  $perm = &drupal_static(__FUNCTION__, array());
  // Mark the group ID and permissions that invoked an alter.
  $perm_alter = &drupal_static(__FUNCTION__ . '_alter', array());

  if (!og_is_group($group_type, $gid)) {
    // Not a group.
    return NULL;
  }


  if (empty($account)) {
    $account = clone $user;
  }

  // User #1 has all privileges.
  if ($account->id() == 1) {
    return TRUE;
  }

  // Administer group permission.
  if ($account->hasPermission('administer group', $account) && !$ignore_admin) {
    return TRUE;
  }

  // Group manager has all privileges (if variable is TRUE).
  $uid = $account->id();
  if (!empty($uid) && \Drupal::config('og.settings')->get('group_manager_full_access')) {
    $group = entity_load($group_type, $gid);
    $group_uid = $group_type == 'node' ? $group->getAuthorId() : $group_type == 'user' ? $group->id() : 0;
    if (!empty($group_uid) && $group_uid == $uid) {
      return TRUE;
    }
  }

  $identifier = $group_type . ':' . $gid;

  // To reduce the number of SQL queries, we cache the user's permissions
  // in a static variable.
  if (!isset($perm[$identifier][$uid])) {
    $roles = og_get_user_roles($group_type, $gid, $uid);
    $role_permissions = og_role_permissions($roles);

    $perms = array();
    foreach ($role_permissions as $one_role) {
      $perms += $one_role;
    }
    $perm[$identifier][$uid] = $perms;
  }

  if (!$skip_alter && empty($perm_alter[$identifier][$uid][$string])) {
    // Let modules alter the permissions. since $perm is static we create
    // a clone of it.
    $group = !empty($group) ? $group : entity_load($group_type, $gid);
    $temp_perm = $perm[$identifier][$uid];
    $context = array(
      'string' => $string,
      'group_type' => $group_type,
      'group' => $group,
      'account' => $account,
    );
    \Drupal::moduleHandler()->alter('og_user_access', $temp_perm, $context);

    // Re-assessing the altered permissions.
    $perm[$identifier][$uid] = $temp_perm;

    // Make sure alter isn't called for the same permissions.
    $perm_alter[$identifier][$uid][$string] = TRUE;
  }

  return !empty($perm[$identifier][$uid][$string]) || (!empty($perm[$identifier][$uid]['administer group']) && !$ignore_admin);
}

/**
 * Creates a new OG membership.
 *
 * If a group membership already exists, an exception will be thrown.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $entity_type
 *   The entity type of the group content.
 * @param $etid
 *   The entity ID of the group content.
 * @param $field_name
 *   The group audience field name.
 * @param $values
 *   (optional) Array of fields values to be attached to the OG membership, that
 *   will be processed using entity-metadata wrapper.
 *
 * @throws \Drupal\og\OgException
 *   When the field_name passed is not a group audience field.
 *
 * @return \Drupal\og\Entity\OgMembership
 *   Returns a new OG membership object.
 *
 * @see entity_property_values_create_entity()
 */
function og_membership_create($group_type, $gid, $entity_type, $etid, $field_name, $values = array()) {
  $language = Drupal::languageManager()->getLanguage();

  $values += array(
    'group_type' => $group_type,
    'gid' => $gid,
    'entity_type' => $entity_type,
    'etid' => $etid,
    'state' => OG_STATE_ACTIVE,
    'created' => time(),
    'field_name' => $field_name,
    'language' => $language->id,
  );

  if (!og_is_group_audience_field($entity_type, $field_name)) {
    throw new \Drupal\og\OgException(format_string('%field-name is not a valid group-audience field.', array('%field-name' => $field_name)));
  }

  $entity = entity_load($entity_type, $etid);
  $bundle = $entity->bundle();

  // Get the type from the field.
  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  $handler_settings = $field->getFieldSetting('handler_settings');
  $values['type'] = $handler_settings['membership_type'];

  return entity_create('og_membership', $values);;
}

/**
 * OG membership loader.
 *
 * @param $name
 *   (optional) The name for this group membership. If no type is given all existing
 *   types are returned.
 *
 * @return OgMembership
 *   Returns a fully-loaded group membership definition if a type name is passed.
 *   Else an array containing all types is returned.
 */
function og_membership_load($name = NULL) {
  return entity_load('og_membership', $name);
}

/**
 * Load multiple OG membership entities based on certain conditions.
 *
 * @param $ids
 *   An array of group membership IDs.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return array
 *   An array of group entities, indexed by group ID.
 */
function og_membership_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load_multiple('og_membership', $ids, $conditions, $reset);
}

/**
 * Get the group membership entity by user and group.
 *
 * @param $group_type
 * @param $gid
 * @param $entity_type
 * @param $etid
 * @return mixed The OgMembership object if found, or FALSE.
 */
function og_get_membership($group_type, $gid, $entity_type, $etid) {
  $return = &drupal_static(__FUNCTION__, array());
  $identifier = $group_type . ':' . $gid . ':' . $entity_type . ':' . $etid;
  if (!isset($return[$identifier])) {
    $return[$identifier] = FALSE;

    $query = \Drupal::entityQuery('og_membership');
    $result = $query
        ->condition('gid', $gid, '=')
        ->condition('group_type', $group_type, '=')
        ->condition('etid', $etid, '=')
        ->condition('entity_type', $entity_type, '=')
        ->execute();

    if (!empty($result['og_membership'])) {
      $key = key($result['og_membership']);
      $return[$identifier] = $key;
    }
  }

  if (!empty($return[$identifier])) {
    $og_membership = og_membership_load($return[$identifier]);
    return $og_membership;
  }
  return FALSE;
}

/**
 * Invalidate cache.
 *
 * @param $gids
 *   Array with group IDs that their cache should be invalidated.
 */
function og_invalidate_cache($gids = array()) {
  // Reset static cache.
  $caches = array(
    'og_user_access',
    'og_user_access_alter',
    'og_role_permissions',
    'og_get_user_roles',
    'og_get_permissions',
    'og_get_group_audience_fields',
  );

  foreach ($caches as $cache) {
    drupal_static_reset($cache);
  }
  // Invalidate group membership cache.
  og_membership_invalidate_cache();

  // Let other OG modules know we invalidate cache.
  \Drupal::moduleHandler()->invokeAll('og_invalidate_cache', $gids);
}

/**
 * Get the groups an entity is associated with.
 *
 * @param $entity_type
 *   The entity type. Defaults to 'user'
 * @param $entity
 *   (optional) The entity object or entity ID. If empty, and $entity_type is
 *   "user", the current user will be used.
 * @param $states
 *   (optional) Array with the state to return. Defaults to active.
 *
 * @return
 *  An array with the group's entity type as the key, and array - keyed by
 *  the OG membership ID and the group ID as the value. If nothing found,
 *  then an empty array.
 */
function og_get_entity_groups($entity_type = 'user', $entity = NULL, $states = array(OG_STATE_ACTIVE)) {
  $cache = &drupal_static(__FUNCTION__, array());

  if ($entity_type == 'user' && empty($entity)) {
    global $user;
    $entity = clone $user;
  }
  if (is_object($entity)) {
    // Get the entity ID.
    $id = $entity->id();
  }
  else {
    $id = $entity;
  }

  // Get a string identifier of the states, so we can retrieve it from cache.
  if ($states) {
    sort($states);
    $state_identifier = implode(':', $states);
  }
  else {
    $state_identifier = 0;
  }

  if (isset($cache[$entity_type][$id][$state_identifier])) {
    // Return cached values.
    //return $cache[$entity_type][$id][$state_identifier];
  }

  $cache[$entity_type][$id][$state_identifier] = array();

  $query = Drupal::entityQuery('og_membership');
  $query
      ->condition('entity_type', $entity_type, '=')
      ->condition('etid', $id, '=');

  if ($states) {
    $query->condition('state', $states, 'IN');
  }

  $result = $query->execute();
  if (!empty($result)) {
    // Get the group ID from the group membership.
    $og_memberships = og_membership_load_multiple(array_keys($result));
    foreach ($og_memberships as $og_membership) {
      $cache[$entity_type][$id][$state_identifier][$og_membership->group_type()][$og_membership->id()] = $og_membership->gid();
    }
  }

  return $cache[$entity_type][$id][$state_identifier];
}

/**
 * Determine if a field is a group audience type.
 *
 * @param $entity_type
 *   The entity_type.
 * @param $field_name
 *   The field name.
 * @return boolean
 *   TRUE|FALSE
 */
function og_is_group_audience_field($entity_type, $field_name) {
  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  $settings = $field->getFieldSettings();
  return $field->getFieldType() == 'entity_reference' && ($settings['handler'] == 'og' || strpos($settings['handler'], 'og_') === 0);
}

/**
 * Get the name of the group-audience type field.
 *
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name to be checked.
 * @param $group_type
 *   Filter list to only include fields referencing a specific group type.
 * @param $group_bundle
 *   Filter list to only include fields referencing a specific group bundle.
 *   Fields that do not specify any bundle restrictions at all are also
 *   included.
 *
 * @return
 *   Array keyed with the field name and the field label as the value.
 */
function og_get_group_audience_fields($entity_type = 'user', $bundle_name = 'user', $group_type = NULL, $group_bundle = NULL) {
  $return = &drupal_static(__FUNCTION__, array());
  $identifier = $entity_type . ':' . $bundle_name . ':' . $group_type;
  if (isset($return[$identifier])) {
    return $return[$identifier];
  }
  $return[$identifier] = array();
  foreach (\Drupal\field\Field::fieldInfo()->getInstances($entity_type) as $key => $instances) {
    if ($key != $bundle_name) {
      continue;
    }
    foreach ($instances as $instance) {
      if (!og_is_group_audience_field($entity_type, $instance->getFieldName())) {
        continue;
      }

      $field_settings = $instance->getField()->getFieldSettings();
      if (isset($group_type) && $field_settings['target_type'] != $group_type) {
        continue;
      }
      if ($group_bundle && !empty($field_settings['handler_settings']['target_bundles']) && !in_array($group_bundle, $field_settings['handler_settings']['target_bundles'])) {
        continue;
      }
      $return[$identifier][$instance->getFieldName()] = $instance->getFieldLabel();
    }

  }

  return $return[$identifier];
}

/**
 * Return the group type (i.e. "group" or "group_content") of an entity.
 *
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name to be checked.
 * @param $type
 *   The group usage type. Must be "group" or "group content".
 *
 * @return boolean
 *   The group type or an "omitted" if node type doesn't participate in
 *   Group.
 */
function og_get_group_type($entity_type, $bundle_name, $type = 'group') {
  if ($type == 'group') {
    return (bool)\Drupal\field\Field::fieldInfo()->getInstance($entity_type, $bundle_name, OG_GROUP_FIELD);
  }
  elseif ($type == 'group content') {
    return (bool)og_get_group_audience_fields($entity_type, $bundle_name);
  }
}

/**
 * Return TRUE if the entity type is a "group" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $entity_type
 *   The entity type to be checked.
 *
 * @param $bundle_name
 *   The bundle name to be checked.
 * @return boolean
 *   TRUE|FALSE depending on whether or not the entity type is a "group" type.
 */
function og_is_group_type($entity_type, $bundle_name) {
  return og_get_group_type($entity_type, $bundle_name);
}

/**
 * Return TRUE if the entity type is a "group content" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $entity_type
 *   The entity type to be checked.
 * @param $bundle_name
 *
 * @return boolean
 */
function og_is_group_content_type($entity_type, $bundle_name) {
  return og_get_group_type($entity_type, $bundle_name, 'group content');
}

/**
 * Return all the entities that are a group content.
 *
 * @return array
 *   Array keyed with the entity type machine name and the entity human readable
 *   name as the value, or an empty array if no entities are defined as group
 *   content.
 */
function og_get_all_group_content_entity() {
  $return = array();

  foreach (Drupal::service('plugin.manager.entity')->getDefinitions() as $entity_type => $entity_value) {
    foreach ($entity_value['bundles'] as $bundle => $bundle_value) {
      if (og_is_group_content_type($entity_type, $bundle)) {
        $return[$entity_type] = check_plain($entity_value['label']);
        // At least one bundle of the entity can be a group, so break.
        break;
      }
    }
  }
  return $return;
}

/**
 * Return all bundles that are a group type.
 *
 * @return array
 *  An associative array whose keys are entity types, and whose values are
 *  arrays of bundles for that entity type. The array of bundles is keyed by
 *  bundle machine name, and the values are bundle labels.
 */
function og_get_all_group_bundle() {
  $return = array();

  foreach (Drupal::service('entity.manager')->getDefinitions() as $entity_type => $entity_value) {
    foreach (entity_get_bundles($entity_type) as $bundle => $bundle_value) {
      if (og_is_group_type($entity_type, $bundle)) {
        $return[$entity_type][$bundle] = check_plain($bundle_value['label']);
      }
    }
  }
  return $return;
}

/**
 * Return all the entities that are a group content.
 *
 * @return array
 *   Array keyed with the entity type machine name and the entity human readable
 *   name as the value, or an empty array if no entities are defined as group
 *   content.
 */
function og_get_all_group_content_bundle() {
  $return = array();

  foreach (entity_get_bundles() as $entity_type => $entity_value) {
    foreach ($entity_value as $bundle => $bundle_value) {
      if (og_is_group_content_type($entity_type, $bundle)) {
        $return[$entity_type][$bundle] = check_plain($bundle_value['label']);
      }
    }
  }
  return $return;
}

/**
 * Return TRUE if entity belongs to a group.
 *
 * @param $group_type
 *   The group type.
 * @param $gid
 *   The group ID.
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object. If empty the current user will be used.
 * @param $states
 *   (optional) Array with the state to return. If empty groups of all state will
 *   return.
 *
 * @return boolean
 *   TRUE if the entity (e.g. the user) belongs to a group and is not pending or
 *   blocked.
 */
function og_is_member($group_type, $gid, $entity_type = 'user', $entity = NULL, $states = array(OG_STATE_ACTIVE)) {
  $groups = og_get_entity_groups($entity_type, $entity, $states);
  return !empty($groups[$group_type]) && in_array($gid, $groups[$group_type]);
}

/**
 * Check if group should use default roles and permissions.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID or the group entity.
 *
 * @return boolean
 *   TRUE if group should use default roles and permissions.
 */
function og_is_group_default_access($group_type, $gid) {
  $entity = entity_load($group_type, $gid);
  $bundle = $entity->bundle();

  if (!\Drupal\field\Field::fieldInfo()->getInstance($group_type, $bundle, OG_DEFAULT_ACCESS_FIELD)) {
    $default = \Drupal::Config('og.settings')->get("is_group_default_access.{$group_type}.{$bundle}");
    return  $default === FALSE ? $default : TRUE;
  }

  if (empty($entity->{OG_DEFAULT_ACCESS_FIELD})) {
    return TRUE;
  }

  return !$entity->{OG_DEFAULT_ACCESS_FIELD}->value();
}

/**
 * Retrieve an array of roles matching specified conditions.
 *
 * @param $group_type
 *   The group type.
 * @param $bundle
 *   The bundle type.
 * @param $gid
 *   The group ID.
 * @param $force_group
 *   (optional) If TRUE then the roles of the group will be retrieved by the
 *   group ID, even if the group is set to have default roles and permissions.
 *   The group might be set to "Default access" but infact there are inactive
 *   group roles. Thus, we are forcing the function to return the overriden
 *   roles. see og_delete_user_roles_by_group().
 * @param $include_all
 *   (optional) If TRUE then the anonymous and authenticated default roles will
 *   be included.
 *
 * @return
 *   An associative array with the role id as the key and the role name as
 *   value. The anonymous and authenticated default roles are on the top of the
 *   array.
 */
function og_roles($group_type, $bundle, $gid = 0, $force_group = FALSE, $include_all = TRUE) {
  if ($gid && !$bundle) {
    $entity = entity_load($group_type, $gid);
    $bundle = $entity->bundle();
  }

  // Check if overriden access exists.
  if ($gid && !$force_group) {
    $query_gid = og_is_group_default_access($group_type, $gid) ? 0 : $gid;
  }
  else {
    $query_gid = $gid;
  }

  $query = db_select('og_role', 'ogr')
      ->fields('ogr', array('rid', 'name'))
      ->condition('group_type', $group_type, '=')
      ->condition('group_bundle', $bundle, '=')
      ->condition('gid', $query_gid, '=')
      ->orderBy('rid', 'ASC');

  if (!$include_all) {
    $query->condition('name', array(OG_ANONYMOUS_ROLE, OG_AUTHENTICATED_ROLE), 'NOT IN');
  }
  $rids = $query
      ->execute()
      ->fetchAllkeyed();

  return $rids;
}

/**
 * Get array of default roles, keyed by their declaring module.
 *
 * @param $include
 *   (optional) If TRUE also anonymous and authenticated roles will be returned.
 *   Defaults to TRUE.
 *
 * @return array
 *   Array of default roles, grouped by module name.
 */
function og_get_default_roles($include = TRUE) {
  $roles = array();
  foreach (\Drupal::moduleHandler()->getImplementations('og_default_roles') as $module) {
    $roles = array_merge($roles, \Drupal::moduleHandler()->invoke($module, 'og_default_roles'));
  }

  // Allow other modules to alter the default roles, except of the anonymous and
  // authenticated.
  \Drupal::moduleHandler()->alter('og_default_roles', $roles);

  if ($include) {
    array_unshift($roles, OG_AUTHENTICATED_ROLE);
    array_unshift($roles, OG_ANONYMOUS_ROLE);
  }

  return $roles;
}

/**
 * Get all roles of a user in a certain group.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $uid
 *   (optional) Integer specifying the user ID. By default an ID of current
 *   logged in user will be used.
 * @param $include
 *   (optional) If TRUE also anonymous or authenticated role ID will be
 *   returned. Defaults to TRUE.
 *
 * @return
 *   Array with the role IDs of the user as the key, and the role name as
 *   the value.
 */
function og_get_user_roles($group_type, $gid, $uid = NULL, $include = TRUE) {
  $roles = &drupal_static(__FUNCTION__, array());
  if (empty($uid)) {
    global $user;
    $uid = $user->id();
  }

  $identifier = implode(':', array($group_type, $gid, $uid, $include));
  if (isset($roles[$identifier])) {
    return $roles[$identifier];
  }

  $group = entity_load($group_type, $gid);
  // Get the bundle of the group.
  $id = $group->id();
  $bundle = $group->bundle();

  // Check if roles are overridden for the group.
  $query_gid = og_is_group_default_access($group_type, $gid) ? 0 : $gid;

  $query = db_select('og_users_roles', 'ogur');
  $query->innerJoin('og_role', 'ogr', 'ogur.rid = ogr.rid');

  $rids = $query
      ->fields('ogur', array('rid'))
      ->fields('ogr', array('name'))
      ->condition('ogr.group_type', $group_type, '=')
      ->condition('ogr.group_bundle', $bundle, '=')
      ->condition('ogr.gid', $query_gid, '=')
      ->condition('ogur.uid', $uid, '=')
      ->condition('ogur.gid', $gid, '=')
      ->orderBy('rid')
      ->execute()
      ->fetchAllkeyed();

  if ($include) {
    $account = user_load($uid);
    $role_name = og_is_member($group_type, $gid, 'user', $account) ? OG_AUTHENTICATED_ROLE : OG_ANONYMOUS_ROLE;

    $rids = db_select('og_role', 'ogr')
            ->fields('ogr', array('rid', 'name'))
            ->condition('group_type', $group_type, '=')
            ->condition('group_bundle', $bundle, '=')
            ->condition('gid', $query_gid, '=')
            ->condition('name', $role_name, '=')
            ->execute()
            ->fetchAllkeyed() + $rids;
  }

  $roles[$identifier] = $rids;
  return $rids;
}

/**
 * Create a stub OG role object.
 *
 * @param $name
 *   A name of the role.
 * @param $group_type
 *   (optional) The entity type of the group.
 * @param $gid
 *   (optional) The group ID.
 * @param $group_bundle
 *   (optional) The bundle of the group.
 *
 * @return object
 *   A stub OG role object.
 */
function og_role_create($name, $group_type = '', $gid = 0, $group_bundle = '') {
  $role = new stdClass;
  $role->name = $name;
  $role->gid = $gid;
  $role->group_type = $group_type;
  $role->group_bundle = $group_bundle;
  return $role;
}

/**
 * Fetch a user role from database.
 *
 * @param $rid
 *   An integer with the role ID.
 *
 * @return object
 *   A fully-loaded role object if a role with the given ID exists,
 *   FALSE otherwise.
 */
function og_role_load($rid) {
  return db_select('og_role', 'r')
      ->fields('r')
      ->condition('rid', $rid)
      ->execute()
      ->fetchObject();
}

/**
 * Save a user role to the database.
 *
 * @param $role
 *   A role object to modify or add. If $role->rid is not specified, a new
 *   role will be created.
 *
 * @return constant
 *   Status constant indicating if role was created or updated.
 *   Failure to write the user role record will return FALSE. Otherwise.
 *   SAVED_NEW or SAVED_UPDATED is returned depending on the operation
 *   performed.
 */
function og_role_save($role) {
  if ($role->name) {
    // Prevent leading and trailing spaces in role names.
    $role->name = trim($role->name);
  }
  if (!empty($role->rid) && $role->name) {
    $status = drupal_write_record('og_role', $role, 'rid');
    \Drupal::ModuleHandler()->invokeAll('og_role_update', $role);
  }
  else {
    $status = drupal_write_record('og_role', $role);
    \Drupal::ModuleHandler()->invokeAll('og_role_insert', $role);
  }

  og_invalidate_cache();
  return $status;
}

/**
 * Delete a user role from database.
 *
 * @param $rid
 *   An integer with the role ID.
 */
function og_role_delete($rid) {
  $role = og_role_load($rid);

  db_delete('og_role')
      ->condition('rid', $rid)
      ->execute();
  db_delete('og_role_permission')
      ->condition('rid', $rid)
      ->execute();
  // Update the users who have this role set.
  db_delete('og_users_roles')
      ->condition('rid', $rid)
      ->execute();

  \Drupal::ModuleHandler()->invokeAll('og_role_delete', $role);

  og_invalidate_cache();
}

/**
 * Delete all roles belonging to a group.
 *
 * @param $group_type
 *   The group type.
 * @param $gid
 *   The group ID.
 */
function og_delete_user_roles_by_group($group_type, $gid) {
  // Check if group has overridden roles defined.
  $group = entity_load($group_type, $gid);
  $gid = $group->id();
  $bundle = $group->bundle();
  if ($roles = og_roles($group_type, $bundle, $gid, TRUE)) {
    foreach ($roles as $rid => $name) {
      og_role_delete($rid);
    }
  }
}

/**
 * Get the role names of role IDs.
 *
 * @param $rids
 *   Array with role IDs.
 * @return
 *  Array keyed by the role ID, and the role name as the value.
 */
function og_get_user_roles_name($rids = array()) {
  if ($rids) {
    $query = db_query("SELECT rid, name FROM {og_role} WHERE rid IN (:rids)", array(':rids' => $rids));
  }
  else {
    $query = db_query("SELECT rid, name FROM {og_role}");
  }
  return $query->fetchAllKeyed();
}


/**
 * Delete all permissions defined by a module.
 *
 * @see og_modules_uninstalled()
 *
 * @param $modules
 *   Array with the module names.
 */
function og_permissions_delete_by_module($modules = array()) {
  db_delete('og_role_permission')
      ->condition('module', $modules, 'IN')
      ->execute();
}

/**
 * Create new roles, based on the default roles and permissions.
 *
 * @param $group_type
 *   The group type.
 * @param $bundle
 *   The bundle type.
 * @param $gid
 *   The group ID.
 *
 * @return array|boolean
 *   The newly created roles keyed by role ID and role name as the value. Or
 *   FALSE if no roles were created.
 */
function og_roles_override($group_type, $bundle, $gid) {
  // Check if roles aren't already overridden. We can't use
  // og_is_group_default_access() as the field is already set, so we
  // check to see if there are new roles in the database by setting
  // "force group" parameter to TRUE.
  if (og_roles($group_type, $bundle, $gid, TRUE)) {
    return FALSE;
  }

  $rids = array();
  if ($gid) {
    // Copy roles from a specific group
    $og_roles = og_roles($group_type, $bundle);
    $perms = og_role_permissions($og_roles);
  }
  else {
    // Copy the global default roles
    $og_roles = og_get_default_roles();
    $perms = og_get_default_permissions();
  }

  foreach ($og_roles as $rid => $name) {
    $role = og_role_create($name, $group_type, $gid, $bundle);
    og_role_save($role);

    $rids[$role->rid] = $role->name;
    og_role_change_permissions($role->rid, $perms[$rid]);

    // Remap the default roles, to the newly created ones.
    db_update('og_users_roles')
        ->fields(array('rid' => $role->rid))
        ->condition('rid', $rid)
        ->condition('group_type', $group_type)
        ->condition('gid', $gid)
        ->execute();
  }

  return $rids;
}

/**
 * Grant a group role to a user.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $uid
 *   The user ID.
 * @param $rid
 *   The role ID.
 */
function og_role_grant($group_type, $gid, $uid, $rid) {
  // Make sure the role is valid.
  $group = entity_load($group_type, $gid);
  $bundle = $group->bundle();
  $og_roles = og_roles($group_type, $bundle, $gid, FALSE, FALSE);
  if (empty($og_roles[$rid])) {
    // Role isn't valid.
    return;
  }

  // Get the existing user roles.
  $user_roles = og_get_user_roles($group_type, $gid, $uid);
  if (empty($user_roles[$rid])) {
    $role = new stdClass();
    $role->uid = $uid;
    $role->rid = $rid;
    $role->group_type = $group_type;
    $role->gid = $gid;

    drupal_write_record('og_users_roles', $role);
    og_invalidate_cache();
    \Drupal::ModuleHandler()->invokeAll('og_role_grant', $group_type, $gid, $uid, $rid);
  }
}

/**
 * Revoke a group role from a user.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $uid
 *   The user ID.
 * @param $rid
 *   The role ID.
 */
function og_role_revoke($group_type, $gid, $uid, $rid) {
  $og_roles = og_get_user_roles($group_type, $gid, $uid);
  if (!empty($og_roles[$rid])) {
    db_delete('og_users_roles')
        ->condition('uid', $uid)
        ->condition('rid', $rid)
        ->condition('group_type', $group_type)
        ->condition('gid', $gid)
        ->execute();
    \Drupal::ModuleHandler()->invokeAll('og_role_revoke', $group_type, $gid, $uid, $rid);
  }
}

/**
 * Change permissions for a user role.
 *
 * This function may be used to grant and revoke multiple permissions at once.
 * For example, when a form exposes checkboxes to configure permissions for a
 * role, the submitted values may be directly passed on in a form submit
 * handler.
 *
 * @param $rid
 *   The ID of a group user role to alter.
 * @param $permissions
 *   An array of permissions, where the key holds the permission name and the
 *   value is an integer or boolean that determines whether to grant or revoke
 *   the permission:
 *   @code
 *     array(
 *       'edit group' => 0,
 *       'administer group' => 1,
 *     )
 *   @endcode
 *   Existing permissions are not changed, unless specified in $permissions.
 *
 * @see og_role_grant_permissions()
 * @see og_role_revoke_permissions()
 */
function og_role_change_permissions($rid, array $permissions = array()) {
  // Grant new permissions for the role.
  $grant = array_filter($permissions);
  if (!empty($grant)) {
    og_role_grant_permissions($rid, array_keys($grant));
  }
  // Revoke permissions for the role.
  $revoke = array_diff_assoc($permissions, $grant);
  if (!empty($revoke)) {
    og_role_revoke_permissions($rid, array_keys($revoke));
  }

  if (!empty($grant) || !empty($revoke)) {
    // Allow modules to be notified on permission changes.
    $role = og_role_load($rid);
    \Drupal::ModuleHandler()->invokeAll('og_role_change_permissions', $role, $grant, $revoke);
  }
}

/**
 * Grant permissions to a user role.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   A list of permission names to grant.
 *
 * @see user_role_change_permissions()
 * @see user_role_revoke_permissions()
 */
function og_role_grant_permissions($rid, array $permissions = array()) {
  $modules = array();
  foreach (og_get_permissions() as $name => $value) {
    $modules[$name] = $value['module'];
  }
  // Grant new permissions for the role.
  foreach ($permissions as $name) {
    // Prevent WSOD, if the permission name is wrong, and we can't find its
    // module.
    if (!empty($modules[$name])) {
      db_merge('og_role_permission')
          ->key(array(
            'rid' => $rid,
            'permission' => $name,
            'module' => $modules[$name],
          ))
          ->execute();
    }
  }
  og_invalidate_cache();
}

/**
 * Revoke permissions from a user role.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   A list of permission names to revoke.
 *
 * @see user_role_change_permissions()
 * @see user_role_grant_permissions()
 */
function og_role_revoke_permissions($rid, array $permissions = array()) {
  // Revoke permissions for the role.
  db_delete('og_role_permission')
      ->condition('rid', $rid)
      ->condition('permission', $permissions, 'IN')
      ->execute();

  og_invalidate_cache();
}

/**
 * Get all permissions defined by implementing modules.
 *
 * @return array
 *  Array keyed with the permissions name and the value of the permissions.
 *  TODO: Write the values.
 */
function og_get_permissions() {
  $perms = &drupal_static(__FUNCTION__, array());
  if (!empty($perms)) {
    return $perms;
  }

  foreach (\Drupal::moduleHandler()->getImplementations('og_permission') as $module) {
    if ($permissions = \Drupal::moduleHandler()->invoke($module, 'og_permission')) {
      foreach ($permissions as $key => $perm) {
        $permissions[$key] += array(
          // Initialize the roles key, if other modules haven't set it
          // explicitly. This means the permissions can apply to anonymous and
          // authenticated members as-well.
          'roles' => array(OG_ANONYMOUS_ROLE, OG_AUTHENTICATED_ROLE),
          'default role' => array(),
          'module' => $module,
        );
      }
      $perms = array_merge($perms, $permissions);
    }
  }

  // Allow other modules to alter the permissions.
  \Drupal::moduleHandler()->alter('og_permission', $perms);

  return $perms;
}

/**
 * Get default permissions.
 *
 * @return array
 *   Array keyed with the anonymous, authenticated and administror and the
 *   permissions that should be enabled by default.
 */
function og_get_default_permissions() {
  $roles = og_get_default_roles();
  $default_perms = og_get_permissions();
  $perms = array();

  foreach ($roles as $rid => $role_name) {
    $perms[$rid] = array();
    // For each default role, iterate default permissions and mark the
    // permissions that set the role as default.
    foreach ($default_perms as $perm_name => $perm) {
      if (in_array($role_name, $perm['default role'])) {
        $perms[$rid][$perm_name] = TRUE;
      }
    }
  }

  return $perms;
}


/**
 * Determine the permissions for one or more roles.
 *
 * @param $roles
 *   An array whose keys are the role IDs of interest.
 *
 * @return array
 *   An array indexed by role ID. Each value is an array whose keys are the
 *   permission strings for the given role ID.
 */
function og_role_permissions($roles = array()) {
  $cache = &drupal_static(__FUNCTION__, array());

  $role_permissions = $fetch = array();

  if ($roles) {
    foreach ($roles as $rid => $name) {
      if (isset($cache[$rid])) {
        $role_permissions[$rid] = $cache[$rid];
      }
      else {
        // Add this rid to the list of those needing to be fetched.
        $fetch[] = $rid;
        // Prepare in case no permissions are returned.
        $cache[$rid] = array();
      }
    }

    if ($fetch) {
      // Get from the database permissions that were not in the static variable.
      // Only role IDs with at least one permission assigned will return rows.
      $result = db_query("SELECT rid, permission FROM {og_role_permission} WHERE rid IN (:fetch)", array(':fetch' => $fetch));

      foreach ($result as $row) {
        $cache[$row->rid][$row->permission] = TRUE;
      }
      foreach ($fetch as $rid) {
        // For every rid, we know we at least assigned an empty array.
        $role_permissions[$rid] = $cache[$rid];
      }
    }
  }

  return $role_permissions;
}

/**
 * Get all the modules fields that can be assigned to fieldable entities.
 *
 * @param $field_name
 *   The field name that was registered for the definition.
 *
 * @return array
 *   An array with the field and instance definitions, or FALSE if not
 *   found.
 */
function og_fields_info($field_name = NULL) {
  $return = &drupal_static(__FUNCTION__, array());

  if (empty($return)) {
    foreach (\Drupal::moduleHandler()->getImplementations('og_fields_info') as $module) {
      if ($fields = \Drupal::moduleHandler()->invoke($module, 'og_fields_info')) {
        foreach ($fields as $key => $field) {
          // Add default values.
          $field += array(
            'entity type' => array(),
            'multiple' => FALSE,
            'description' => '',
          );

          // Add the module information.
          $return[$key] = array_merge($field, array('module' => $module));
        }
      }
    }

    // Allow other modules to alter the field info.
    \Drupal::moduleHandler()->alter('og_fields_info', $return);
  }

  if (!empty($field_name)) {
    return !empty($return[$field_name]) ?  $return[$field_name] : FALSE;
  }

  return $return;
}

/**
 * Implements hook_og_fields_info().
 */
function og_og_fields_info() {
  $items[OG_GROUP_FIELD] = array(
    'type' => array('group'),
    'description' => t('Determine if this should be a group.'),
    'field' => array(
      'name' => OG_GROUP_FIELD,
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array(
        'allowed_values' => array(0 => 'Not a group', 1 => 'Group'),
        'allowed_values_function' => '',
      ),
    ),
    'instance' => array(
      'label' => t('Group'),
      'description' => t('Determine if this is an OG group.'),
      'display_label' => 1,
      'widget' => array(
        'module' => 'options',
        'settings' => array(
          'og_hide' => TRUE,
        ),
        'type' => 'options_onoff',
        'weight' => 0,
      ),
      'default_value' => array(0 => array('value' => 1)),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'og_group_subscribe',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'og_group_subscribe',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  $items[OG_DEFAULT_ACCESS_FIELD] = array(
    'type' => array('group'),
    'description' => t('Determine if group should use default roles and permissions.'),
    'field' => array(
      'name' => OG_DEFAULT_ACCESS_FIELD,
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array('allowed_values' => array(0 => 'Use default roles and permissions', 1 => 'Override default roles and permissions'), 'allowed_values_function' => ''),
    ),
    'instance' => array(
      'label' => t('Group roles and permissions'),
      'widget' => array(
        'module' => 'options',
        'settings' => array(),
        'type' => 'options_select',
      ),
      'required' => TRUE,
      // Use default role and permissions as default value.
      'default_value' => array(0 => array('value' => 0)),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'list_default',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'list_default',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  $items[OG_AUDIENCE_FIELD] = array(
    'multiple' => TRUE,
    'type' => array('group content'),
    'description' => t('Determine to which groups this group content is assigned to.'),
    'field' => array(
      'name' => OG_AUDIENCE_FIELD,
      'type' => 'entity_reference',
      'cardinality' => \Drupal\Core\Field\FieldDefinitionInterface::CARDINALITY_UNLIMITED,
      'active' => true,
      'settings' => array(
        'handler' => 'og',
        'handler_submit' => 'Change handler',
        'handler_settings' => array(
          'behaviors' => array(
            'og_behavior' => array(
              'status' => TRUE,
            ),
          ),
          'target_bundles' => array(),
          'membership_type' => OG_MEMBERSHIP_TYPE_DEFAULT,
        ),
        'target_type' => 'node',
      ),
    ),
    'instance' => array(
      'label' => t('Groups audience'),
      'widget' => array(
        'type' => 'og_complex',
        'module' => 'og',
        'settings' => array(),
      ),
      'settings' => array(
        'handler' => 'og',
        'handler_submit' => 'Change handler',
        'handler_settings' => array(
          'behaviors' => array(
            'og_behavior' => array(
              'status' => TRUE,
            ),
          ),
          'target_bundles' => array(),
          'membership_type' => OG_MEMBERSHIP_TYPE_DEFAULT,
        ),
        'behaviors' => array(
          'og_widget' => array(
            'status' => TRUE,
            'default' => array(
              'widget_type' => 'options_select',
            ),
            'admin' => array(
              'widget_type' => 'entity_reference_autocomplete',
            ),
          ),
        ),
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'og_list_default',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'og_list_default',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  return $items;
}

/**
 * Set breadcrumbs according to a given group.
 *
 * @param $entity_type
 *   The entity type.
 * @param $etid
 *   The entity ID.
 * @param $path
 *   (optional) The path to append to the breadcrumb.
 */
function og_set_breadcrumb($entity_type, $etid, $path = array()) {
  $entity = entity_load($entity_type, $etid);
  $label = $entity->label();
  $uri = $entity->uri();
  \Drupal::service('breadcrumb')->build(array_merge(array(l(t('Home'), '<front>')), array(l($label, $uri['path'])), $path));
}

/**
 * Create an organic groups field in a bundle.
 *
 * @param $field_name
 *   The field name
 * @param $entity_type
 *   The entity type
 * @param $bundle
 *   The bundle name.
 * @param $og_field
 *   (optional) Array with field definitions, to allow easier overriding by the
 *   caller. If empty, function will get the field info by calling
 *   og_fields_info() with the field name.
 */
function og_create_field($field_name, $entity_type, $bundle, $og_field = array()) {
  if (empty($og_field)) {
    $og_field = og_fields_info($field_name);
  }

  $field = \Drupal\field\Field::fieldInfo()->getField($entity_type, $field_name);
  // Allow overriding the field name.
  $og_field['field']['name'] = $field_name;
  // Allow overriding the entity type.
  $og_field['field']['entity_type'] = $entity_type;
  if (empty($field)) {
    $field =  $field = entity_create('field_entity', $og_field['field']);
    $field->save();
  }

  $instance = \Drupal\field\Field::fieldInfo()->getInstance($entity_type, $bundle, $field_name);
  if (empty($instance)) {
    $instance = $og_field['instance'];
    $instance += array(
      'field_name' => $field_name,
      'bundle' => $bundle,
      'entity_type' => $entity_type,
    );

    $instance = entity_create('field_instance', $instance);
    $instance->save();

    // Need to set widget independently from instance.
    entity_get_form_display($entity_type, $bundle, 'default')
      ->setComponent($field_name, $og_field['instance']['widget'])
      ->save();

    // Set view modes.
    foreach ($og_field['instance']['view modes'] as $view_mode => $settings) {
      entity_get_display('node', $bundle, $view_mode)
        ->setComponent($field_name, $settings)
        ->save();
    }

    // Clear the entity property info cache, as OG fields might add different
    // entity property info.
    og_invalidate_cache();
    entity_info_cache_clear();
  }
}

/**
 * Return the states a group can be in.
 */
function og_group_states() {
  return array(
    OG_STATE_ACTIVE => t('Active'),
    OG_STATE_PENDING => t('Pending'),
  );
}

/**
 * Return the states a group content can be in.
 */
function og_group_content_states() {
  return array(
    OG_STATE_ACTIVE => t('Active'),
    OG_STATE_PENDING => t('Pending'),
    OG_STATE_BLOCKED => t('Blocked'),
  );
}

/**
 * Helper function to generate standard node permission list for a given type.
 *
 * @param $type
 *   The machine-readable name of the node type.
 *
 * @return array
 *   An array of permission names and descriptions.
 */
function og_list_permissions($type) {
  $info = node_type_load($type);
  $type = check_plain($info->type);
  $perms = array();

  // Check type is of group content.
  if (og_is_group_content_type('node', $type)) {
    // Build standard list of node permissions for this type.
    $perms += array(
      "create $type content" => array(
        'title' => t('Create %type_name content', array('%type_name' => $info->name)),

      ),
      "update own $type content" => array(
        'title' => t('Edit own %type_name content', array('%type_name' => $info->name)),
      ),
      "update any $type content" => array(
        'title' => t('Edit any %type_name content', array('%type_name' => $info->name)),
      ),
      "delete own $type content" => array(
        'title' => t('Delete own %type_name content', array('%type_name' => $info->name)),
      ),
      "delete any $type content" => array(
        'title' => t('Delete any %type_name content', array('%type_name' => $info->name)),
      ),
    );

    if (!\Drupal::moduleHandler()->moduleExists('entityreference_prepopulate')) {
      // We allow the create permission only on members, as otherwise we would
      // have to iterate over every single group to decide if the user has
      // permissions for it.
      $perms["create $type content"]['roles'] = array(OG_AUTHENTICATED_ROLE);
    }

    // Add default permissions.
    foreach ($perms as $key => $value) {
      $perms[$key]['default role'] = array(OG_AUTHENTICATED_ROLE);
    }
  }
  return $perms;
}